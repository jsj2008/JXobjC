#line 2 "/ws/PortableObjectCompiler/objc/flex.m"

#line 4 "/ws/PortableObjectCompiler/objc/flex.m"

#define YY_INT_ALIGNED short int

/* A lexical scanner generated by flex */

#define FLEX_SCANNER
#define YY_FLEX_MAJOR_VERSION 2
#define YY_FLEX_MINOR_VERSION 5
#define YY_FLEX_SUBMINOR_VERSION 37
#if YY_FLEX_SUBMINOR_VERSION > 0
#define FLEX_BETA
#endif

/* First, we deal with  platform-specific or compiler-specific issues. */

#if defined(__FreeBSD__)
#ifndef __STDC_LIMIT_MACROS
#define __STDC_LIMIT_MACROS
#endif
#include <sys/cdefs.h>
#include <stdint.h>
#else
#define __dead2
#endif

/* begin standard C headers. */
#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <stdlib.h>

/* end standard C headers. */

/* flex integer type definitions */

#ifndef FLEXINT_H
#define FLEXINT_H

/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */

#if defined(__FreeBSD__) ||                                                    \
    (defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L)

/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
 * if you want the limit (max/min) macros for int types.
 */
#ifndef __STDC_LIMIT_MACROS
#define __STDC_LIMIT_MACROS 1
#endif

#include <inttypes.h>
typedef int8_t flex_int8_t;
typedef uint8_t flex_uint8_t;
typedef int16_t flex_int16_t;
typedef uint16_t flex_uint16_t;
typedef int32_t flex_int32_t;
typedef uint32_t flex_uint32_t;
#else
typedef signed char flex_int8_t;
typedef short int flex_int16_t;
typedef int flex_int32_t;
typedef unsigned char flex_uint8_t;
typedef unsigned short int flex_uint16_t;
typedef unsigned int flex_uint32_t;

/* Limits of integral types. */
#ifndef INT8_MIN
#define INT8_MIN (-128)
#endif
#ifndef INT16_MIN
#define INT16_MIN (-32767 - 1)
#endif
#ifndef INT32_MIN
#define INT32_MIN (-2147483647 - 1)
#endif
#ifndef INT8_MAX
#define INT8_MAX (127)
#endif
#ifndef INT16_MAX
#define INT16_MAX (32767)
#endif
#ifndef INT32_MAX
#define INT32_MAX (2147483647)
#endif
#ifndef UINT8_MAX
#define UINT8_MAX (255U)
#endif
#ifndef UINT16_MAX
#define UINT16_MAX (65535U)
#endif
#ifndef UINT32_MAX
#define UINT32_MAX (4294967295U)
#endif

#endif /* ! C99 */

#endif /* ! FLEXINT_H */

#ifdef __cplusplus

/* The "const" storage-class-modifier is valid. */
#define YY_USE_CONST

#else /* ! __cplusplus */

/* C99 requires __STDC__ to be defined as 1. */
#if defined(__STDC__)

#define YY_USE_CONST

#endif /* defined (__STDC__) */
#endif /* ! __cplusplus */

#ifdef YY_USE_CONST
#define yyconst const
#else
#define yyconst
#endif

/* Returned upon end-of-file. */
#define YY_NULL 0

/* Promotes a possibly negative, possibly signed char to an unsigned
 * integer for use as an array index.  If the signed char is negative,
 * we want to instead treat it as an 8-bit unsigned char, hence the
 * double cast.
 */
#define YY_SC_TO_UI(c) ((unsigned int)(unsigned char)c)

/* Enter a start condition.  This macro really ought to take a parameter,
 * but we do it the disgusting crufty way forced on us by the ()-less
 * definition of BEGIN.
 */
#define BEGIN (yy_start) = 1 + 2 *

/* Translate the current start state into a value that can be later handed
 * to BEGIN to return to the state.  The YYSTATE alias is for lex
 * compatibility.
 */
#define YY_START (((yy_start)-1) / 2)
#define YYSTATE YY_START

/* Action number for EOF rule of a given start state. */
#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)

/* Special action meaning "start processing a new file". */
#define YY_NEW_FILE yyrestart (yyin)

#define YY_END_OF_BUFFER_CHAR 0

/* Size of default input buffer. */
#ifndef YY_BUF_SIZE
#define YY_BUF_SIZE 16384
#endif

/* The state buf must be large enough to hold one state per character in the
 * main buffer.
 */
#define YY_STATE_BUF_SIZE ((YY_BUF_SIZE + 2) * sizeof (yy_state_type))

#ifndef YY_TYPEDEF_YY_BUFFER_STATE
#define YY_TYPEDEF_YY_BUFFER_STATE
typedef struct yy_buffer_state * YY_BUFFER_STATE;
#endif

#ifndef YY_TYPEDEF_YY_SIZE_T
#define YY_TYPEDEF_YY_SIZE_T
typedef size_t yy_size_t;
#endif

extern yy_size_t yyleng;

extern FILE *yyin, *yyout;

#define EOB_ACT_CONTINUE_SCAN 0
#define EOB_ACT_END_OF_FILE 1
#define EOB_ACT_LAST_MATCH 2

#define YY_LESS_LINENO(n)

/* Return all but the first "n" matched characters back to the input stream. */
#define yyless(n)                                                              \
    do                                                                         \
    {                                                                          \
        /* Undo effects of setting up yytext. */                               \
        int yyless_macro_arg = (n);                                            \
        YY_LESS_LINENO (yyless_macro_arg);                                     \
        *yy_cp = (yy_hold_char);                                               \
        YY_RESTORE_YY_MORE_OFFSET (yy_c_buf_p) = yy_cp =                       \
            yy_bp + yyless_macro_arg - YY_MORE_ADJ;                            \
        YY_DO_BEFORE_ACTION; /* set up yytext again */                         \
    } while (0)

#define unput(c) yyunput (c, (yytext_ptr))

#ifndef YY_STRUCT_YY_BUFFER_STATE
#define YY_STRUCT_YY_BUFFER_STATE
struct yy_buffer_state
{
    FILE * yy_input_file;

    char * yy_ch_buf;  /* input buffer */
    char * yy_buf_pos; /* current position in input buffer */

    /* Size of input buffer in bytes, not including room for EOB
     * characters.
     */
    yy_size_t yy_buf_size;

    /* Number of characters read into yy_ch_buf, not including EOB
     * characters.
     */
    yy_size_t yy_n_chars;

    /* Whether we "own" the buffer - i.e., we know we created it,
     * and can realloc() it to grow it, and should free() it to
     * delete it.
     */
    int yy_is_our_buffer;

    /* Whether this is an "interactive" input source; if so, and
     * if we're using stdio for input, then we want to use getc()
     * instead of fread(), to make sure we stop fetching input after
     * each newline.
     */
    int yy_is_interactive;

    /* Whether we're considered to be at the beginning of a line.
     * If so, '^' rules will be active on the next match, otherwise
     * not.
     */
    int yy_at_bol;

    int yy_bs_lineno; /**< The line count. */
    int yy_bs_column; /**< The column count. */

    /* Whether to try to fill the input buffer when we reach the
     * end of it.
     */
    int yy_fill_buffer;

    int yy_buffer_status;

#define YY_BUFFER_NEW 0
#define YY_BUFFER_NORMAL 1
/* When an EOF's been seen but there's still some text to process
 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
 * shouldn't try reading from the input source any more.  We might
 * still have a bunch of tokens to match, though, because of
 * possible backing-up.
 *
 * When we actually see the EOF, we change the status to "new"
 * (via yyrestart()), so that the user can continue scanning by
 * just pointing yyin at a new input file.
 */
#define YY_BUFFER_EOF_PENDING 2
};
#endif /* !YY_STRUCT_YY_BUFFER_STATE */

/* Stack of input buffers. */
static size_t yy_buffer_stack_top = 0;        /**< index of top of stack. */
static size_t yy_buffer_stack_max = 0;        /**< capacity of stack. */
static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */

/* We provide macros for accessing buffer states in case in the
 * future we want to put the buffer states in a more general
 * "scanner state".
 *
 * Returns the top of the stack, or NULL.
 */
#define YY_CURRENT_BUFFER                                                      \
    ((yy_buffer_stack) ? (yy_buffer_stack)[(yy_buffer_stack_top)] : NULL)
#define yy_current_buffer YY_CURRENT_BUFFER

/* Same as previous macro, but useful when we know that the buffer stack is not
 * NULL or when we need an lvalue. For internal use only.
 */
#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]

/* yy_hold_char holds the character lost when yytext is formed. */
static char yy_hold_char;
static yy_size_t yy_n_chars; /* number of characters read into yy_ch_buf */
yy_size_t yyleng;

/* Points to current character in buffer. */
static char * yy_c_buf_p = (char *)0;
static int yy_init = 0;  /* whether we need to initialize */
static int yy_start = 0; /* start state number */

/* Flag which is used to allow yywrap()'s to do buffer switches
 * instead of setting up a fresh yyin.  A bit of a hack ...
 */
static int yy_did_buffer_switch_on_eof;

void yyrestart (FILE * input_file);
void yy_switch_to_buffer (YY_BUFFER_STATE new_buffer);
YY_BUFFER_STATE yy_create_buffer (FILE * file, int size);
void yy_delete_buffer (YY_BUFFER_STATE b);
void yy_flush_buffer (YY_BUFFER_STATE b);
void yypush_buffer_state (YY_BUFFER_STATE new_buffer);
void yypop_buffer_state (void);

static void yyensure_buffer_stack (void);
static void yy_load_buffer_state (void);
static void yy_init_buffer (YY_BUFFER_STATE b, FILE * file);

#define YY_FLUSH_BUFFER yy_flush_buffer (YY_CURRENT_BUFFER)

YY_BUFFER_STATE yy_scan_buffer (char * base, yy_size_t size);
YY_BUFFER_STATE yy_scan_string (yyconst char * yy_str);
YY_BUFFER_STATE yy_scan_bytes (yyconst char * bytes, yy_size_t len);

void * yyalloc (yy_size_t);
void * yyrealloc (void *, yy_size_t);
void yyfree (void *);

#define yy_new_buffer yy_create_buffer

#define yy_set_interactive(is_interactive)                                     \
    {                                                                          \
        if (!YY_CURRENT_BUFFER)                                                \
        {                                                                      \
            yyensure_buffer_stack ();                                          \
            YY_CURRENT_BUFFER_LVALUE = yy_create_buffer (yyin, YY_BUF_SIZE);   \
        }                                                                      \
        YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive;          \
    }

#define yy_set_bol(at_bol)                                                     \
    {                                                                          \
        if (!YY_CURRENT_BUFFER)                                                \
        {                                                                      \
            yyensure_buffer_stack ();                                          \
            YY_CURRENT_BUFFER_LVALUE = yy_create_buffer (yyin, YY_BUF_SIZE);   \
        }                                                                      \
        YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol;                          \
    }

#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)

/* Begin user sect3 */

typedef unsigned char YY_CHAR;

FILE *yyin = (FILE *)0, *yyout = (FILE *)0;

typedef int yy_state_type;

extern int yylineno;

int yylineno = 1;

extern char * yytext;
#define yytext_ptr yytext

static yy_state_type yy_get_previous_state (void);
static yy_state_type yy_try_NUL_trans (yy_state_type current_state);
static int yy_get_next_buffer (void);
static void yy_fatal_error (yyconst char msg[]) __dead2;

/* Done after the current pattern has been matched and before the
 * corresponding action - sets up yytext.
 */
#define YY_DO_BEFORE_ACTION                                                    \
    (yytext_ptr) = yy_bp;                                                      \
    yyleng = (size_t) (yy_cp - yy_bp);                                         \
    (yy_hold_char) = *yy_cp;                                                   \
    *yy_cp = '\0';                                                             \
    (yy_c_buf_p) = yy_cp;

#define YY_NUM_RULES 180
#define YY_END_OF_BUFFER 181
/* This struct is not used in this scanner,
   but its presence is necessary. */
struct yy_trans_info
{
    flex_int32_t yy_verify;
    flex_int32_t yy_nxt;
};
static yyconst flex_int16_t yy_accept[748] = {
    0,   0,   0,   181, 179, 165, 166, 166, 124, 179, 179, 177, 130, 141, 179,
    118, 119, 128, 131, 159, 132, 123, 129, 173, 173, 147, 160, 135, 148, 137,
    146, 179, 120, 121, 142, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177,
    177, 177, 177, 177, 177, 177, 177, 177, 161, 143, 162, 125, 165, 166, 140,
    0,   168, 0,   0,   167, 167, 177, 153, 144, 154, 0,   170, 0,   151, 126,
    149, 127, 150, 122, 0,   176, 178, 152, 174, 171, 173, 0,   173, 0,   133,
    136, 164, 139, 138, 134, 0,   0,   0,   0,   0,   0,

    156, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177,
    177, 177, 177, 177, 177, 177, 177, 9,   177, 177, 177, 177, 177, 177, 177,
    50,  19,  177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177,
    177, 177, 155, 145, 0,   0,   0,   0,   0,   0,   163, 0,   176, 178, 174,
    0,   174, 171, 0,   175, 173, 172, 157, 158, 0,   0,   0,   0,   0,   0,
    0,   0,   177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177,
    177, 177, 177, 177, 177, 177, 177, 177, 177, 177,

    177, 177, 177, 177, 177, 177, 177, 177, 177, 57,  177, 177, 177, 177, 177,
    177, 177, 177, 177, 177, 177, 86,  177, 17,  177, 177, 21,  177, 177, 177,
    177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177,
    177, 177, 0,   0,   0,   0,   0,   0,   0,   176, 176, 0,   174, 0,   174,
    174, 171, 175, 173, 172, 0,   0,   48,  0,   0,   0,   0,   0,   0,   0,
    177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177,
    177, 177, 177, 177, 177, 177, 177, 177, 177, 177,

    177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 85,  177, 177,
    177, 177, 1,   35,  177, 4,   6,   177, 177, 177, 177, 11,  12,  177, 177,
    18,  177, 22,  177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177,
    177, 177, 177, 33,  177, 177, 177, 0,   0,   0,   0,   0,   0,   176, 0,
    174, 174, 174, 171, 175, 172, 44,  0,   0,   0,   0,   0,   0,   0,   0,
    0,   2,   177, 177, 177, 177, 177, 177, 177, 177, 73,  177, 177, 177, 177,
    177, 177, 177, 177, 177, 84,  177, 177, 177, 177,

    177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177,
    177, 177, 177, 177, 88,  177, 177, 3,   40,  177, 177, 177, 177, 16,  177,
    177, 177, 177, 177, 177, 25,  177, 177, 177, 177, 177, 177, 31,  177, 62,
    177, 177, 34,  0,   0,   174, 175, 172, 0,   0,   0,   0,   0,   0,   0,
    0,   0,   177, 177, 177, 177, 177, 111, 177, 177, 0,   177, 0,   177, 177,
    177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 100, 177, 177, 177, 177,
    177, 87,  177, 177, 177, 177, 177, 103, 177, 177,

    177, 177, 177, 177, 177, 177, 82,  177, 177, 177, 177, 177, 10,  15,  56,
    177, 89,  177, 177, 24,  42,  26,  27,  28,  29,  177, 177, 177, 177, 49,
    0,   0,   0,   0,   0,   52,  0,   0,   177, 177, 177, 177, 104, 117, 177,
    0,   74,  0,   58,  177, 95,  83,  177, 177, 67,  177, 177, 177, 177, 110,
    177, 177, 177, 99,  177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177,
    177, 177, 177, 177, 177, 75,  90,  177, 177, 8,   0,   0,   177, 177, 177,
    30,  177, 177, 36,  0,   0,   55,  0,   0,   0,

    0,   116, 5,   177, 115, 177, 0,   177, 0,   177, 177, 177, 177, 177, 93,
    177, 177, 177, 77,  177, 107, 177, 177, 177, 177, 177, 177, 68,  177, 177,
    63,  79,  177, 177, 177, 91,  7,   0,   0,   177, 23,  41,  32,  43,  0,
    0,   53,  0,   51,  45,  177, 177, 0,   177, 0,   112, 177, 177, 64,  94,
    177, 177, 177, 105, 177, 177, 177, 0,   177, 177, 101, 102, 177, 92,  109,
    177, 177, 37,  0,   0,   177, 0,   46,  54,  20,  177, 0,   177, 38,  39,
    96,  177, 97,  76,  177, 177, 0,   113, 80,  108,

    69,  70,  65,  13,  0,   0,   61,  0,   177, 0,   0,   177, 0,   177, 106,
    98,  177, 177, 177, 0,   0,   61,  0,   169, 59,  0,   177, 0,   114, 177,
    81,  71,  66,  14,  0,   0,   72,  78,  0,   0,   0,   47,  0,   0,   60,
    60,  0};

static yyconst flex_int32_t yy_ec[256] = {
    0,  1,  1,  1,  1,  1,  1,  1,  1,  2,  3,  1,  1,  4,  1,  1,  1,  1,  1,
    1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  5,  6,  7,  8,  9,  10,
    11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 26, 28,
    28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 36, 39, 40, 41, 41, 42, 41, 41,
    43, 41, 44, 45, 46, 41, 41, 47, 48, 49, 41, 41, 50, 41, 41, 51, 52, 53, 54,
    55, 1,  56, 57, 58, 59,

    60, 61, 62, 63, 64, 41, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77,
    78, 79, 80, 81, 82, 83, 84, 1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
    1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
    1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
    1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
    1,  1,  1,  1,  1,

    1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
    1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
    1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1};

static yyconst flex_int32_t yy_meta[85] = {
    0, 1, 2, 3, 3, 2, 1, 1, 1, 4, 1, 1, 5, 1, 1, 1, 1, 5, 1, 1, 1, 6,
    6, 6, 6, 6, 6, 6, 6, 1, 1, 1, 1, 1, 1, 1, 7, 7, 7, 7, 7, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 1, 1, 1, 1, 4, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 1, 1, 1};

static yyconst flex_int16_t yy_base[766] = {
    0,    0,    0,    1329, 1330, 83,   1330, 1325, 1295, 79,   86,   0,
    1294, 76,   80,   1330, 1330, 1293, 75,   1330, 77,   75,   73,   114,
    174,  1330, 1330, 80,   84,   82,   1330, 86,   1330, 1330, 1292, 213,
    31,   48,   65,   58,   83,   96,   1254, 107,  1253, 1265, 1264, 1259,
    107,  1239, 51,   1248, 67,   1330, 90,   1330, 1330, 121,  1330, 1330,
    136,  1330, 280,  144,  1330, 1313, 0,    1330, 1330, 1330, 117,  1330,
    352,  1330, 1330, 1330, 1330, 1330, 1330, 1296, 410,  0,    1330, 456,
    160,  0,    272,  111,  0,    1282, 1330, 1330, 1330, 1330, 1281, 1252,
    1243, 111,  101,  1250, 1249,

    1330, 116,  1239, 1240, 1236, 1249, 127,  483,  1245, 1247, 1234, 1241,
    1244, 1225, 1231, 1223, 1227, 1235, 1221, 1237, 1224, 1230, 1215, 1216,
    1213, 1213, 1214, 1216, 1212, 1209, 0,    0,    116,  1214, 1214, 1207,
    142,  1210, 132,  111,  1214, 1207, 141,  1212, 154,  1212, 1210, 1330,
    1330, 344,  220,  0,    435,  297,  0,    1330, 482,  196,  0,    273,
    503,  223,  242,  418,  540,  297,  339,  1330, 1330, 1212, 149,  1202,
    1197, 155,  1213, 1198, 1202, 1198, 1202, 1198, 1208, 1189, 1204, 1199,
    1187, 1210, 148,  1202, 206,  1197, 1178, 192,  1180, 1186, 1184, 1192,
    1179, 1190, 271,  174,

    1181, 1179, 1189, 1186, 1173, 1178, 1187, 1169, 1182, 0,    1171, 1173,
    1182, 1177, 1164, 155,  1179, 1177, 1173, 1165, 1171, 0,    1174, 0,
    1160, 1164, 0,    1165, 1166, 1167, 1160, 1149, 1147, 1149, 1152, 1159,
    1144, 1142, 1142, 1155, 1145, 1149, 1144, 1152, 1154, 1153, 1142, 563,
    609,  650,  442,  700,  741,  550,  598,  340,  586,  349,  570,  763,
    350,  654,  357,  1330, 761,  1134, 1137, 1330, 1139, 1144, 1127, 182,
    1136, 1126, 1140, 1133, 1132, 1127, 1134, 1129, 1129, 1171, 1118, 1147,
    1123, 1115, 1115, 1127, 1130, 1117, 1118, 1125, 208,  158,  1110, 1119,
    159,  211,  1124, 1123,

    1105, 1101, 249,  1114, 1116, 1101, 1101, 1102, 1098, 1104, 1106, 1110,
    0,    1103, 1094, 1107, 1106, 0,    0,    1098, 0,    0,    1088, 1097,
    1085, 1093, 0,    0,    1086, 1083, 0,    1088, 0,    1082, 1098, 1080,
    1080, 1079, 1076, 1089, 1079, 1083, 1088, 1087, 1085, 1075, 1080, 1079,
    0,    1066, 1067, 1078, 273,  0,    816,  258,  0,    857,  1330, 629,
    879,  471,  1330, 1330, 472,  782,  1330, 1078, 1076, 1063, 1078, 1073,
    1072, 1067, 1066, 1071, 0,    1054, 1061, 1062, 1061, 1064, 1096, 1062,
    1083, 393,  1048, 1059, 1060, 1045, 1043, 1040, 1048, 1044, 1052, 1089,
    1036, 1035, 1048, 1043,

    301,  1047, 1043, 1032, 1041, 1028, 1041, 275,  1039, 1031, 1040, 1039,
    1036, 1035, 1030, 1037, 1036, 1025, 1022, 0,    1033, 1032, 0,    0,
    1019, 1020, 1025, 1016, 0,    1023, 1012, 1015, 1006, 1015, 1010, 0,
    1018, 1015, 1011, 994,  988,  982,  0,    973,  0,    962,  969,  0,
    355,  332,  1330, 1330, 1330, 937,  929,  934,  920,  908,  913,  907,
    876,  870,  879,  882,  873,  871,  879,  0,    870,  888,  488,  880,
    851,  869,  873,  865,  331,  856,  856,  855,  855,  858,  898,  866,
    851,  0,    853,  895,  840,  852,  855,  0,    842,  836,  827,  838,
    836,  0,    831,  834,

    833,  832,  818,  824,  797,  798,  0,    809,  802,  801,  791,  791,
    0,    859,  858,  806,  0,    801,  802,  0,    0,    0,    0,    0,
    0,    798,  798,  785,  776,  1330, 789,  791,  786,  771,  761,  1330,
    774,  764,  764,  752,  772,  761,  0,    0,    781,  0,    0,    739,
    1330, 764,  807,  0,    792,  795,  762,  746,  745,  740,  740,  0,
    756,  755,  749,  0,    736,  734,  739,  740,  731,  734,  725,  725,
    724,  716,  710,  716,  713,  705,  708,  716,  0,    0,    704,  695,
    0,    747,  685,  693,  678,  675,  0,    689,  687,  0,    678,  687,
    1330, 665,  683,  669,

    669,  0,    0,    663,  0,    689,  324,  658,  718,  676,  675,  664,
    652,  657,  0,    652,  649,  646,  658,  630,  0,    635,  689,  643,
    638,  625,  638,  641,  629,  627,  0,    0,    632,  625,  611,  0,
    0,    646,  627,  621,  0,    0,    0,    0,    606,  603,  1330, 603,
    1330, 1330, 581,  614,  355,  570,  629,  1330, 568,  566,  0,    0,
    581,  560,  562,  0,    572,  548,  549,  591,  529,  527,  0,    0,
    544,  0,    0,    523,  521,  0,    257,  512,  549,  496,  1330, 1330,
    0,    495,  484,  488,  0,    0,    532,  468,  0,    0,    461,  472,
    506,  1330, 463,  0,

    0,    447,  442,  1330, 476,  413,  0,    377,  374,  677,  450,  372,
    411,  366,  0,    0,    364,  362,  357,  396,  326,  0,    327,  0,
    470,  486,  332,  371,  1330, 326,  0,    0,    0,    1330, 277,  269,
    0,    0,    198,  164,  153,  1330, 95,   139,  0,    0,    1330, 945,
    954,  960,  968,  977,  981,  983,  985,  991,  1000, 1004, 1012, 1021,
    1030, 1039, 1048, 1057, 1066};

static yyconst flex_int16_t yy_def[766] = {
    0,   747, 1,   747, 747, 747, 747, 747, 747, 748, 749, 750, 747, 747, 751,
    747, 747, 747, 747, 747, 747, 747, 747, 747, 747, 747, 747, 747, 747, 747,
    747, 747, 747, 747, 747, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750,
    750, 750, 750, 750, 750, 750, 750, 750, 747, 747, 747, 747, 747, 747, 747,
    748, 747, 747, 749, 747, 747, 750, 747, 747, 747, 751, 747, 747, 747, 747,
    747, 747, 747, 747, 747, 747, 752, 747, 747, 23,  24,  747, 747, 753, 747,
    747, 747, 747, 747, 747, 747, 747, 747, 747, 747, 747,

    747, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750,
    750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750,
    750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750,
    750, 750, 747, 747, 748, 748, 754, 751, 751, 755, 747, 747, 747, 752, 83,
    747, 747, 747, 747, 747, 747, 753, 747, 747, 747, 747, 747, 747, 747, 747,
    747, 747, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750,
    750, 750, 750, 750, 750, 750, 750, 750, 750, 750,

    750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750,
    750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750,
    750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750,
    750, 750, 748, 748, 249, 751, 751, 252, 747, 747, 747, 747, 747, 747, 747,
    747, 747, 747, 747, 747, 747, 747, 747, 747, 747, 747, 747, 747, 747, 747,
    750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750,
    750, 750, 750, 750, 750, 750, 750, 750, 750, 750,

    750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750,
    750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750,
    750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750,
    750, 750, 750, 750, 750, 750, 750, 748, 250, 250, 751, 253, 253, 747, 747,
    747, 747, 747, 747, 747, 747, 747, 747, 747, 747, 747, 747, 747, 747, 747,
    747, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750,
    750, 750, 750, 750, 750, 750, 750, 750, 750, 750,

    750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750,
    750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750,
    750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750,
    750, 750, 750, 748, 751, 747, 747, 747, 747, 747, 747, 747, 747, 747, 747,
    747, 747, 750, 750, 750, 750, 750, 750, 750, 750, 756, 750, 757, 750, 750,
    750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750,
    750, 750, 750, 750, 750, 750, 750, 750, 750, 750,

    750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750,
    750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 747,
    747, 747, 747, 747, 747, 747, 747, 747, 750, 750, 750, 750, 750, 750, 750,
    758, 750, 757, 747, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750,
    750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750,
    750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 747, 747, 750, 750, 750,
    750, 750, 750, 750, 747, 747, 747, 747, 747, 747,

    747, 750, 750, 750, 750, 750, 758, 750, 759, 750, 750, 750, 750, 750, 750,
    750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750,
    750, 750, 750, 750, 750, 750, 750, 747, 747, 750, 750, 750, 750, 750, 747,
    747, 747, 747, 747, 747, 750, 750, 760, 750, 759, 747, 750, 750, 750, 750,
    750, 750, 750, 750, 750, 750, 750, 761, 750, 750, 750, 750, 750, 750, 750,
    750, 750, 750, 747, 747, 750, 747, 747, 747, 750, 750, 760, 750, 750, 750,
    750, 750, 750, 750, 750, 750, 761, 747, 750, 750,

    750, 750, 750, 747, 747, 747, 762, 747, 750, 747, 763, 750, 764, 750, 750,
    750, 750, 750, 750, 747, 747, 762, 747, 750, 763, 763, 750, 764, 747, 750,
    750, 750, 750, 747, 747, 747, 750, 750, 747, 747, 747, 747, 747, 747, 765,
    765, 0,   747, 747, 747, 747, 747, 747, 747, 747, 747, 747, 747, 747, 747,
    747, 747, 747, 747, 747};

static yyconst flex_int16_t yy_nxt[1415] = {
    0,   4,   5,   6,   7,   5,   8,   9,   10,  11,  12,  13,  14,  15,  16,
    17,  18,  19,  20,  21,  22,  23,  24,  24,  24,  24,  24,  24,  24,  25,
    26,  27,  28,  29,  30,  31,  11,  11,  11,  11,  11,  11,  11,  11,  11,
    11,  11,  11,  11,  11,  11,  32,  4,   33,  34,  35,  36,  37,  38,  39,
    40,  41,  42,  11,  43,  11,  44,  11,  45,  11,  46,  11,  47,  48,  49,
    50,  51,  52,  11,  11,  11,  53,  54,  55,  56,  57,  61,  68,  57,  64,
    65,  74,  71,  81,  79,  76,  80,  80,  80,  80,  80,

    80,  80,  80,  115, 82,  116, 75,  69,  77,  78,  89,  90,  91,  93,  94,
    92,  117, 122, 143, 118, 119, 148, 57,  144, 146, 57,  123, 120, 71,  147,
    62,  72,  83,  121, 84,  84,  84,  84,  84,  84,  84,  85,  61,  745, 95,
    96,  64,  65,  124, 97,  125, 127, 86,  166, 744, 98,  87,  99,  100, 166,
    126, 128, 87,  88,  129, 131, 237, 132, 72,  138, 139, 149, 174, 86,  133,
    175, 166, 172, 173, 87,  140, 226, 238, 141, 178, 166, 184, 62,  87,  227,
    179, 88,  83,  235, 85,  85,  85,  85,  85,  85,

    85,  85,  163, 231, 241, 185, 267, 268, 163, 747, 743, 236, 86,  242, 232,
    233, 87,  244, 271, 245, 285, 286, 87,  272, 400, 163, 61,  323, 324, 396,
    397, 742, 401, 86,  163, 256, 307, 747, 256, 87,  248, 248, 248, 248, 248,
    248, 248, 294, 87,  102, 103, 372, 308, 741, 104, 373, 256, 105, 106, 107,
    295, 256, 261, 704, 288, 261, 402, 108, 289, 71,  109, 62,  705, 110, 290,
    291, 111, 394, 403, 61,  112, 395, 113, 261, 262, 114, 60,  164, 261, 164,
    262, 60,  165, 165, 165, 165, 165, 165, 165, 165,

    150, 151, 151, 151, 151, 151, 151, 262, 71,  72,  408, 257, 258, 60,  409,
    258, 262, 251, 251, 251, 251, 251, 251, 251, 62,  653, 302, 488, 653, 152,
    303, 60,  257, 258, 304, 60,  60,  740, 258, 264, 60,  496, 497, 71,  305,
    264, 739, 60,  72,  306, 61,  60,  553, 60,  554, 60,  653, 152, 70,  653,
    489, 61,  264, 70,  248, 248, 248, 248, 248, 248, 248, 264, 153, 154, 154,
    154, 154, 154, 154, 359, 738, 265, 359, 72,  729, 70,  737, 265, 362, 363,
    736, 362, 363, 249, 471, 62,  365, 471, 735, 365,

    359, 155, 734, 70,  265, 359, 62,  70,  70,  362, 363, 733, 70,  265, 362,
    363, 732, 365, 731, 70,  730, 249, 365, 70,  729, 70,  727, 70,  724, 155,
    80,  80,  80,  80,  80,  80,  80,  80,  165, 165, 165, 165, 165, 165, 165,
    165, 71,  472, 157, 158, 723, 726, 158, 71,  726, 251, 251, 251, 251, 251,
    251, 251, 356, 356, 356, 356, 356, 356, 356, 157, 158, 747, 721, 473, 747,
    158, 160, 160, 160, 160, 160, 160, 160, 160, 252, 710, 72,  726, 710, 471,
    726, 720, 471, 72,  161, 162, 719, 254, 162, 254,

    711, 718, 255, 255, 255, 255, 255, 255, 255, 255, 451, 452, 252, 451, 452,
    161, 162, 717, 259, 698, 259, 162, 186, 260, 260, 260, 260, 260, 260, 260,
    260, 451, 452, 716, 715, 714, 451, 452, 187, 188, 189, 190, 191, 192, 713,
    193, 194, 712, 195, 709, 196, 708, 197, 707, 198, 199, 200, 201, 202, 203,
    165, 165, 165, 165, 165, 165, 165, 165, 473, 61,  255, 255, 255, 255, 255,
    255, 255, 255, 706, 263, 703, 702, 263, 353, 353, 353, 353, 353, 353, 353,
    260, 260, 260, 260, 260, 260, 260, 260, 701, 700,

    263, 360, 699, 360, 698, 263, 361, 361, 361, 361, 361, 361, 361, 361, 62,
    61,  696, 695, 255, 255, 255, 255, 255, 255, 255, 255, 694, 693, 692, 354,
    354, 354, 354, 354, 354, 354, 354, 158, 691, 690, 158, 689, 656, 688, 354,
    354, 354, 354, 354, 361, 361, 361, 361, 361, 361, 361, 361, 686, 158, 685,
    62,  684, 683, 158, 354, 354, 354, 354, 354, 354, 355, 355, 355, 355, 355,
    355, 355, 355, 710, 682, 681, 710, 680, 679, 678, 355, 355, 355, 355, 355,
    677, 676, 675, 711, 674, 673, 364, 672, 671, 670,

    669, 668, 364, 667, 666, 355, 355, 355, 355, 355, 355, 71,  665, 664, 663,
    662, 661, 660, 659, 364, 357, 357, 357, 357, 357, 357, 357, 357, 364, 658,
    657, 656, 654, 652, 651, 357, 357, 357, 357, 357, 650, 649, 648, 647, 646,
    645, 644, 643, 642, 641, 640, 72,  639, 638, 637, 357, 357, 357, 357, 357,
    357, 358, 358, 358, 358, 358, 358, 358, 358, 636, 635, 634, 633, 632, 631,
    630, 358, 358, 358, 358, 358, 629, 628, 260, 260, 260, 260, 260, 260, 260,
    260, 627, 626, 625, 624, 623, 358, 358, 358, 358,

    358, 358, 162, 366, 622, 162, 621, 620, 619, 366, 618, 617, 616, 615, 614,
    613, 612, 611, 610, 609, 608, 549, 606, 162, 453, 605, 366, 604, 162, 603,
    453, 602, 601, 600, 599, 366, 449, 449, 449, 449, 449, 449, 449, 449, 598,
    597, 596, 453, 595, 594, 593, 449, 449, 449, 449, 449, 453, 592, 591, 590,
    589, 588, 587, 586, 585, 584, 583, 582, 581, 580, 579, 449, 449, 449, 449,
    449, 449, 450, 450, 450, 450, 450, 450, 450, 450, 578, 577, 576, 575, 574,
    573, 572, 450, 450, 450, 450, 450, 571, 570, 361,

    361, 361, 361, 361, 361, 361, 361, 569, 568, 567, 566, 565, 450, 450, 450,
    450, 450, 450, 258, 564, 563, 258, 562, 561, 560, 559, 558, 557, 556, 555,
    552, 551, 550, 549, 547, 545, 544, 543, 542, 258, 541, 540, 539, 538, 258,
    60,  60,  537, 60,  60,  60,  60,  60,  60,  63,  63,  63,  63,  63,  63,
    63,  63,  63,  66,  536, 66,  66,  66,  70,  70,  535, 70,  70,  70,  70,
    70,  70,  159, 159, 534, 159, 159, 159, 159, 159, 159, 167, 167, 250, 250,
    253, 253, 546, 533, 532, 531, 530, 546, 546, 546,

    548, 548, 548, 548, 548, 548, 548, 548, 548, 607, 607, 607, 655, 655, 655,
    655, 655, 655, 655, 655, 655, 687, 687, 529, 687, 528, 687, 687, 687, 687,
    697, 697, 697, 697, 697, 697, 697, 697, 697, 722, 527, 526, 722, 722, 722,
    722, 722, 722, 725, 725, 525, 725, 725, 725, 725, 725, 725, 728, 728, 728,
    728, 728, 728, 728, 728, 728, 746, 524, 523, 746, 746, 746, 746, 746, 746,
    522, 521, 520, 519, 518, 517, 516, 515, 514, 513, 512, 511, 510, 509, 508,
    507, 506, 505, 504, 503, 502, 501, 500, 499, 498,

    495, 494, 493, 492, 491, 490, 487, 486, 485, 484, 483, 482, 481, 480, 479,
    478, 477, 476, 475, 474, 470, 469, 468, 467, 466, 465, 464, 463, 462, 461,
    460, 459, 458, 457, 456, 455, 454, 448, 447, 446, 445, 444, 443, 442, 441,
    440, 439, 438, 437, 436, 435, 434, 433, 432, 431, 430, 429, 428, 427, 426,
    425, 424, 423, 422, 421, 420, 419, 418, 417, 416, 415, 414, 413, 412, 411,
    410, 407, 406, 405, 404, 399, 398, 393, 392, 391, 390, 389, 388, 387, 386,
    385, 384, 383, 382, 381, 380, 379, 378, 377, 376,

    375, 374, 371, 370, 369, 368, 367, 352, 351, 350, 349, 348, 347, 346, 345,
    344, 343, 342, 341, 340, 339, 338, 337, 336, 335, 334, 333, 332, 331, 330,
    329, 328, 327, 326, 325, 322, 321, 320, 319, 318, 317, 316, 315, 314, 313,
    312, 311, 310, 309, 301, 300, 299, 298, 297, 296, 293, 292, 287, 284, 283,
    282, 281, 280, 279, 278, 277, 276, 275, 274, 273, 270, 269, 266, 247, 246,
    243, 240, 239, 234, 230, 229, 228, 225, 224, 223, 222, 221, 220, 219, 218,
    217, 216, 215, 214, 213, 212, 211, 210, 209, 208,

    207, 206, 205, 204, 183, 182, 181, 180, 177, 176, 171, 170, 169, 168, 156,
    64,  145, 142, 137, 136, 135, 134, 130, 101, 73,  67,  59,  58,  747, 3,
    747, 747, 747, 747, 747, 747, 747, 747, 747, 747, 747, 747, 747, 747, 747,
    747, 747, 747, 747, 747, 747, 747, 747, 747, 747, 747, 747, 747, 747, 747,
    747, 747, 747, 747, 747, 747, 747, 747, 747, 747, 747, 747, 747, 747, 747,
    747, 747, 747, 747, 747, 747, 747, 747, 747, 747, 747, 747, 747, 747, 747,
    747, 747, 747, 747, 747, 747, 747, 747, 747, 747,

    747, 747, 747, 747, 747, 747, 747, 747, 747, 747, 747, 747, 747, 747};

static yyconst flex_int16_t yy_chk[1415] = {
    0,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
    1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
    1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
    1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
    1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
    1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   5,   9,   13,  5,   10,
    10,  18,  14,  22,  21,  20,  21,  21,  21,  21,  21,

    21,  21,  21,  36,  22,  36,  18,  13,  20,  20,  27,  27,  28,  29,  29,
    28,  37,  39,  50,  37,  38,  54,  57,  50,  52,  57,  39,  38,  70,  52,
    9,   14,  23,  38,  23,  23,  23,  23,  23,  23,  23,  23,  60,  744, 31,
    31,  63,  63,  40,  31,  40,  41,  23,  87,  743, 31,  23,  31,  31,  87,
    40,  41,  23,  23,  41,  43,  140, 43,  70,  48,  48,  54,  98,  23,  43,
    98,  87,  97,  97,  23,  48,  133, 140, 48,  102, 87,  107, 60,  23,  133,
    102, 23,  24,  139, 24,  24,  24,  24,  24,  24,

    24,  24,  84,  137, 143, 107, 171, 171, 84,  84,  741, 139, 24,  143, 137,
    137, 24,  145, 174, 145, 187, 187, 24,  174, 297, 84,  151, 216, 216, 294,
    294, 740, 297, 24,  84,  158, 200, 84,  158, 24,  151, 151, 151, 151, 151,
    151, 151, 192, 24,  35,  35,  272, 200, 739, 35,  272, 158, 35,  35,  35,
    192, 158, 162, 679, 189, 162, 298, 35,  189, 356, 35,  151, 679, 35,  189,
    189, 35,  293, 298, 353, 35,  293, 35,  162, 163, 35,  62,  86,  162, 86,
    163, 62,  86,  86,  86,  86,  86,  86,  86,  86,

    62,  62,  62,  62,  62,  62,  62,  163, 154, 356, 303, 160, 160, 62,  303,
    160, 163, 154, 154, 154, 154, 154, 154, 154, 353, 607, 199, 401, 607, 62,
    199, 62,  160, 160, 199, 62,  62,  736, 160, 166, 62,  408, 408, 450, 199,
    166, 735, 62,  154, 199, 150, 62,  477, 62,  477, 62,  653, 62,  72,  653,
    401, 449, 166, 72,  150, 150, 150, 150, 150, 150, 150, 166, 72,  72,  72,
    72,  72,  72,  72,  256, 730, 167, 256, 450, 728, 72,  727, 167, 258, 261,
    723, 258, 261, 150, 386, 150, 263, 386, 721, 263,

    256, 72,  720, 72,  167, 256, 449, 72,  72,  258, 261, 719, 72,  167, 258,
    261, 718, 263, 717, 72,  714, 150, 263, 72,  713, 72,  712, 72,  709, 72,
    80,  80,  80,  80,  80,  80,  80,  80,  164, 164, 164, 164, 164, 164, 164,
    164, 153, 386, 80,  80,  708, 711, 80,  251, 711, 153, 153, 153, 153, 153,
    153, 153, 251, 251, 251, 251, 251, 251, 251, 80,  80,  725, 706, 386, 725,
    80,  83,  83,  83,  83,  83,  83,  83,  83,  153, 687, 153, 726, 687, 471,
    726, 705, 471, 251, 83,  83,  703, 157, 83,  157,

    687, 702, 157, 157, 157, 157, 157, 157, 157, 157, 362, 365, 153, 362, 365,
    83,  83,  699, 161, 697, 161, 83,  108, 161, 161, 161, 161, 161, 161, 161,
    161, 362, 365, 696, 695, 692, 362, 365, 108, 108, 108, 108, 108, 108, 691,
    108, 108, 688, 108, 686, 108, 682, 108, 681, 108, 108, 108, 108, 108, 108,
    165, 165, 165, 165, 165, 165, 165, 165, 471, 248, 254, 254, 254, 254, 254,
    254, 254, 254, 680, 165, 677, 676, 165, 248, 248, 248, 248, 248, 248, 248,
    259, 259, 259, 259, 259, 259, 259, 259, 673, 670,

    165, 257, 669, 257, 668, 165, 257, 257, 257, 257, 257, 257, 257, 257, 248,
    249, 667, 666, 255, 255, 255, 255, 255, 255, 255, 255, 665, 663, 662, 249,
    249, 249, 249, 249, 249, 249, 249, 255, 661, 658, 255, 657, 655, 654, 249,
    249, 249, 249, 249, 360, 360, 360, 360, 360, 360, 360, 360, 652, 255, 651,
    249, 648, 646, 255, 249, 249, 249, 249, 249, 249, 250, 250, 250, 250, 250,
    250, 250, 250, 710, 645, 640, 710, 639, 638, 635, 250, 250, 250, 250, 250,
    634, 633, 630, 710, 629, 628, 262, 627, 626, 625,

    624, 623, 262, 622, 620, 250, 250, 250, 250, 250, 250, 252, 619, 618, 617,
    616, 614, 613, 612, 262, 252, 252, 252, 252, 252, 252, 252, 252, 262, 611,
    610, 609, 608, 606, 604, 252, 252, 252, 252, 252, 601, 600, 599, 598, 596,
    595, 593, 592, 590, 589, 588, 252, 587, 586, 584, 252, 252, 252, 252, 252,
    252, 253, 253, 253, 253, 253, 253, 253, 253, 583, 580, 579, 578, 577, 576,
    575, 253, 253, 253, 253, 253, 574, 573, 260, 260, 260, 260, 260, 260, 260,
    260, 572, 571, 570, 569, 568, 253, 253, 253, 253,

    253, 253, 260, 265, 567, 260, 566, 565, 563, 265, 562, 561, 559, 558, 557,
    556, 555, 554, 553, 551, 550, 548, 545, 260, 366, 542, 265, 541, 260, 540,
    366, 539, 538, 537, 535, 265, 355, 355, 355, 355, 355, 355, 355, 355, 534,
    533, 532, 366, 531, 529, 528, 355, 355, 355, 355, 355, 366, 527, 526, 519,
    518, 516, 515, 514, 512, 511, 510, 509, 508, 506, 505, 355, 355, 355, 355,
    355, 355, 358, 358, 358, 358, 358, 358, 358, 358, 504, 503, 502, 501, 500,
    499, 497, 358, 358, 358, 358, 358, 496, 495, 361,

    361, 361, 361, 361, 361, 361, 361, 494, 493, 491, 490, 489, 358, 358, 358,
    358, 358, 358, 361, 488, 487, 361, 485, 484, 483, 482, 481, 480, 479, 478,
    476, 475, 474, 473, 472, 470, 469, 467, 466, 361, 465, 464, 463, 462, 361,
    748, 748, 461, 748, 748, 748, 748, 748, 748, 749, 749, 749, 749, 749, 749,
    749, 749, 749, 750, 460, 750, 750, 750, 751, 751, 459, 751, 751, 751, 751,
    751, 751, 752, 752, 458, 752, 752, 752, 752, 752, 752, 753, 753, 754, 754,
    755, 755, 756, 457, 456, 455, 454, 756, 756, 756,

    757, 757, 757, 757, 757, 757, 757, 757, 757, 758, 758, 758, 759, 759, 759,
    759, 759, 759, 759, 759, 759, 760, 760, 447, 760, 446, 760, 760, 760, 760,
    761, 761, 761, 761, 761, 761, 761, 761, 761, 762, 444, 442, 762, 762, 762,
    762, 762, 762, 763, 763, 441, 763, 763, 763, 763, 763, 763, 764, 764, 764,
    764, 764, 764, 764, 764, 764, 765, 440, 439, 765, 765, 765, 765, 765, 765,
    438, 437, 435, 434, 433, 432, 431, 430, 428, 427, 426, 425, 422, 421, 419,
    418, 417, 416, 415, 414, 413, 412, 411, 410, 409,

    407, 406, 405, 404, 403, 402, 400, 399, 398, 397, 396, 395, 394, 393, 392,
    391, 390, 389, 388, 387, 385, 384, 383, 382, 381, 380, 379, 378, 376, 375,
    374, 373, 372, 371, 370, 369, 368, 352, 351, 350, 348, 347, 346, 345, 344,
    343, 342, 341, 340, 339, 338, 337, 336, 335, 334, 332, 330, 329, 326, 325,
    324, 323, 320, 317, 316, 315, 314, 312, 311, 310, 309, 308, 307, 306, 305,
    304, 302, 301, 300, 299, 296, 295, 292, 291, 290, 289, 288, 287, 286, 285,
    284, 283, 282, 281, 280, 279, 278, 277, 276, 275,

    274, 273, 271, 270, 269, 267, 266, 247, 246, 245, 244, 243, 242, 241, 240,
    239, 238, 237, 236, 235, 234, 233, 232, 231, 230, 229, 228, 226, 225, 223,
    221, 220, 219, 218, 217, 215, 214, 213, 212, 211, 209, 208, 207, 206, 205,
    204, 203, 202, 201, 198, 197, 196, 195, 194, 193, 191, 190, 188, 186, 185,
    184, 183, 182, 181, 180, 179, 178, 177, 176, 175, 173, 172, 170, 147, 146,
    144, 142, 141, 138, 136, 135, 134, 130, 129, 128, 127, 126, 125, 124, 123,
    122, 121, 120, 119, 118, 117, 116, 115, 114, 113,

    112, 111, 110, 109, 106, 105, 104, 103, 100, 99,  96,  95,  94,  89,  79,
    65,  51,  49,  47,  46,  45,  44,  42,  34,  17,  12,  8,   7,   3,   747,
    747, 747, 747, 747, 747, 747, 747, 747, 747, 747, 747, 747, 747, 747, 747,
    747, 747, 747, 747, 747, 747, 747, 747, 747, 747, 747, 747, 747, 747, 747,
    747, 747, 747, 747, 747, 747, 747, 747, 747, 747, 747, 747, 747, 747, 747,
    747, 747, 747, 747, 747, 747, 747, 747, 747, 747, 747, 747, 747, 747, 747,
    747, 747, 747, 747, 747, 747, 747, 747, 747, 747,

    747, 747, 747, 747, 747, 747, 747, 747, 747, 747, 747, 747, 747, 747};

static yy_state_type yy_last_accepting_state;
static char * yy_last_accepting_cpos;

extern int yy_flex_debug;
int yy_flex_debug = 0;

/* The intent behind this definition is that it'll catch
 * any uses of REJECT which flex missed.
 */
#define REJECT reject_used_but_not_detected
#define yymore() yymore_used_but_not_detected
#define YY_MORE_ADJ 0
#define YY_RESTORE_YY_MORE_OFFSET
char * yytext;
#line 1 "/ws/PortableObjectCompiler/objc/lex.lm"
/*
 * Copyright (c) 1997,98,99,2000,2001,2002,2014 David Stes.
 *
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Library General Public License as published
 * by the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 *
 * $Id: lex.lm,v 1.11 2014/02/26 16:22:44 stes Exp $
 */
#line 23 "/ws/PortableObjectCompiler/objc/lex.lm"
#include "config.h"
#include <assert.h>
#ifndef __OBJECT_INCLUDED__
#define __OBJECT_INCLUDED__
#include <stdio.h>  /* FILE */
#include "Object.h" /* Stepstone Object.h assumes #import */
#endif
#include <ocstring.h>
#include "symbol.h"
#include "node.h"
#include "stclass.h"
#include "util.h"
#include "y.tab.h"
#include "type.h"
#include "options.h"
#include "stmt.h"
#include "dasmstmt.h"

#define YY_NEVER_INTERACTIVE 1
#define YY_DECL int yylex_raw ()

extern id yylval;

int identif (void);
int keyw (int x);
int tkeyw (int x, id t);
int gnukeyw (int x);
int msdoskeyw (int x);
int watcomkeyw (int x);
int ibmvackeyw (int x);

/* set to YES if '{' is beginning of an Objective-C Block */
int okblock;

/* a decimal digit / exponent */
/* octal and hexademical constants */
/* escape seq such as \' or \\ or \n */
/* WATCOM does things like '\0x0d' instead of '\x0d' (as it should be) */
/* stuff for being able to scan files Unix/Mac */
/* an escape seq or any char other than backslash, double quote or newline */
/* SGI has extensions such as LUL as int.suffix */
#line 1090 "/ws/PortableObjectCompiler/objc/flex.m"

#define INITIAL 0

#ifndef YY_NO_UNISTD_H
/* Special case for "unistd.h", since it is non-ANSI. We include it way
 * down here because we want the user's section 1 to have been scanned first.
 * The user has a chance to override it with an option.
 */
#include <unistd.h>
#endif

#ifndef YY_EXTRA_TYPE
#define YY_EXTRA_TYPE void *
#endif

static int yy_init_globals (void);

/* Accessor methods to globals.
   These are made visible to non-reentrant scanners for convenience. */

int yylex_destroy (void);

int yyget_debug (void);

void yyset_debug (int debug_flag);

YY_EXTRA_TYPE yyget_extra (void);

void yyset_extra (YY_EXTRA_TYPE user_defined);

FILE * yyget_in (void);

void yyset_in (FILE * in_str);

FILE * yyget_out (void);

void yyset_out (FILE * out_str);

yy_size_t yyget_leng (void);

char * yyget_text (void);

int yyget_lineno (void);

void yyset_lineno (int line_number);

/* Macros after this point can all be overridden by user definitions in
 * section 1.
 */

#ifndef YY_SKIP_YYWRAP
#ifdef __cplusplus
extern "C" int yywrap (void);
#else
extern int yywrap (void);
#endif
#endif

#ifndef YY_NO_UNPUT
static void yyunput (int c, char * buf_ptr);
#endif

#ifndef yytext_ptr
static void yy_flex_strncpy (char *, yyconst char *, int);
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen (yyconst char *);
#endif

#ifndef YY_NO_INPUT

#ifdef __cplusplus
static int yyinput (void);
#else
static int input (void);
#endif

#endif

/* Amount of stuff to slurp up with each read. */
#ifndef YY_READ_BUF_SIZE
#define YY_READ_BUF_SIZE 8192
#endif

/* Copy whatever the last rule matched to the standard output. */
#ifndef ECHO
/* This used to be an fputs(), but since the string might contain NUL's,
 * we now use fwrite().
 */
#define ECHO                                                                   \
    do                                                                         \
    {                                                                          \
        if (fwrite (yytext, yyleng, 1, yyout))                                 \
        {                                                                      \
        }                                                                      \
    } while (0)
#endif

/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
 * is returned in "result".
 */
#ifndef YY_INPUT
#define YY_INPUT(buf, result, max_size)                                        \
    if (YY_CURRENT_BUFFER_LVALUE->yy_is_interactive)                           \
    {                                                                          \
        int c = '*';                                                           \
        size_t n;                                                              \
        for (n = 0; n < max_size && (c = getc (yyin)) != EOF && c != '\n';     \
             ++n)                                                              \
            buf[n] = (char)c;                                                  \
        if (c == '\n')                                                         \
            buf[n++] = (char)c;                                                \
        if (c == EOF && ferror (yyin))                                         \
            YY_FATAL_ERROR ("input in flex scanner failed");                   \
        result = n;                                                            \
    }                                                                          \
    else                                                                       \
    {                                                                          \
        errno = 0;                                                             \
        while ((result = fread (buf, 1, max_size, yyin)) == 0 &&               \
               ferror (yyin))                                                  \
        {                                                                      \
            if (errno != EINTR)                                                \
            {                                                                  \
                YY_FATAL_ERROR ("input in flex scanner failed");               \
                break;                                                         \
            }                                                                  \
            errno = 0;                                                         \
            clearerr (yyin);                                                   \
        }                                                                      \
    }

#endif

/* No semi-colon after return; correct usage is to write "yyterminate();" -
 * we don't want an extra ';' after the "return" because that will cause
 * some compilers to complain about unreachable statements.
 */
#ifndef yyterminate
#define yyterminate() return YY_NULL
#endif

/* Number of entries by which start-condition stack grows. */
#ifndef YY_START_STACK_INCR
#define YY_START_STACK_INCR 25
#endif

/* Report a fatal error. */
#ifndef YY_FATAL_ERROR
#define YY_FATAL_ERROR(msg) yy_fatal_error (msg)
#endif

/* end tables serialization structures and prototypes */

/* Default declaration of generated scanner - a define so the user can
 * easily add parameters.
 */
#ifndef YY_DECL
#define YY_DECL_IS_OURS 1

extern int yylex (void);

#define YY_DECL int yylex (void)
#endif /* !YY_DECL */

/* Code executed at the beginning of each rule, after yytext and yyleng
 * have been set up.
 */
#ifndef YY_USER_ACTION
#define YY_USER_ACTION
#endif

/* Code executed at the end of each rule. */
#ifndef YY_BREAK
#define YY_BREAK break;
#endif

#define YY_RULE_SETUP YY_USER_ACTION

/** The main scanner function which does all the work.
 */
YY_DECL
{
    yy_state_type yy_current_state;
    char *yy_cp, *yy_bp;
    int yy_act;

#line 91 "/ws/PortableObjectCompiler/objc/lex.lm"

#line 1277 "/ws/PortableObjectCompiler/objc/flex.m"

    if (!(yy_init))
    {
        (yy_init) = 1;

#ifdef YY_USER_INIT
        YY_USER_INIT;
#endif

        if (!(yy_start))
            (yy_start) = 1; /* first start state */

        if (!yyin)
            yyin = stdin;

        if (!yyout)
            yyout = stdout;

        if (!YY_CURRENT_BUFFER)
        {
            yyensure_buffer_stack ();
            YY_CURRENT_BUFFER_LVALUE = yy_create_buffer (yyin, YY_BUF_SIZE);
        }

        yy_load_buffer_state ();
    }

    while (1) /* loops until end-of-file is reached */
    {
        yy_cp = (yy_c_buf_p);

        /* Support of yytext. */
        *yy_cp = (yy_hold_char);

        /* yy_bp points to the position in yy_ch_buf of the start of
         * the current run.
         */
        yy_bp = yy_cp;

        yy_current_state = (yy_start);
    yy_match:
        do
        {
            YY_CHAR yy_c = yy_ec[YY_SC_TO_UI (*yy_cp)];
            if (yy_accept[yy_current_state])
            {
                (yy_last_accepting_state) = yy_current_state;
                (yy_last_accepting_cpos) = yy_cp;
            }
            while (yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state)
            {
                yy_current_state = (int)yy_def[yy_current_state];
                if (yy_current_state >= 748)
                    yy_c = yy_meta[(unsigned int)yy_c];
            }
            yy_current_state =
                yy_nxt[yy_base[yy_current_state] + (unsigned int)yy_c];
            ++yy_cp;
        } while (yy_base[yy_current_state] != 1330);

    yy_find_action:
        yy_act = yy_accept[yy_current_state];
        if (yy_act == 0)
        { /* have to back up */
            yy_cp = (yy_last_accepting_cpos);
            yy_current_state = (yy_last_accepting_state);
            yy_act = yy_accept[yy_current_state];
        }

        YY_DO_BEFORE_ACTION;

    do_action: /* This label is used only to access EOF actions. */

        switch (yy_act)
        {       /* beginning of action switch */
        case 0: /* must back up */
            /* undo the effects of YY_DO_BEFORE_ACTION */
            *yy_cp = (yy_hold_char);
            yy_cp = (yy_last_accepting_cpos);
            yy_current_state = (yy_last_accepting_state);
            goto yy_find_action;

        case 1:
            YY_RULE_SETUP
#line 93 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return keyw (storageclass);
            }
            YY_BREAK
        case 2:
            YY_RULE_SETUP
#line 94 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return keyw (typeword);
            }
            YY_BREAK
        case 3:
            YY_RULE_SETUP
#line 95 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return keyw (breakkeyw);
            }
            YY_BREAK
        case 4:
            YY_RULE_SETUP
#line 96 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return keyw (casekeyw);
            }
            YY_BREAK
        case 5:
            YY_RULE_SETUP
#line 97 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return keyw (typeword);
            }
            YY_BREAK
        case 6:
            YY_RULE_SETUP
#line 98 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return keyw (typeword);
            }
            YY_BREAK
        case 7:
            YY_RULE_SETUP
#line 99 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return keyw (continuekeyw);
            }
            YY_BREAK
        case 8:
            YY_RULE_SETUP
#line 100 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return keyw (defaultkeyw);
            }
            YY_BREAK
        case 9:
            YY_RULE_SETUP
#line 101 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return keyw (dokeyw);
            }
            YY_BREAK
        case 10:
            YY_RULE_SETUP
#line 102 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return keyw (typeword);
            }
            YY_BREAK
        case 11:
            YY_RULE_SETUP
#line 103 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return keyw (elsekeyw);
            }
            YY_BREAK
        case 12:
            YY_RULE_SETUP
#line 104 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return keyw (enumkeyw);
            }
            YY_BREAK
        case 13:
            YY_RULE_SETUP
#line 105 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                if (o_cplus)
                    return keyw (externlang);
            }
            YY_BREAK
        case 14:
            YY_RULE_SETUP
#line 106 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                if (o_cplus)
                    return keyw (externlang);
            }
            YY_BREAK
        case 15:
            YY_RULE_SETUP
#line 107 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return keyw (storageclass);
            }
            YY_BREAK
        case 16:
            YY_RULE_SETUP
#line 108 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return keyw (typeword);
            }
            YY_BREAK
        case 17:
            YY_RULE_SETUP
#line 109 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return keyw (forkeyw);
            }
            YY_BREAK
        case 18:
            YY_RULE_SETUP
#line 110 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return keyw (gotokeyw);
            }
            YY_BREAK
        case 19:
            YY_RULE_SETUP
#line 111 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return keyw (ifkeyw);
            }
            YY_BREAK
        case 20:
            YY_RULE_SETUP
#line 112 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return keyw (typeword);
            }
            YY_BREAK
        case 21:
            YY_RULE_SETUP
#line 113 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return keyw (typeword);
            }
            YY_BREAK
        case 22:
            YY_RULE_SETUP
#line 114 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return keyw (typeword);
            }
            YY_BREAK
        case 23:
            YY_RULE_SETUP
#line 115 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return keyw (storageclass);
            }
            YY_BREAK
        case 24:
            YY_RULE_SETUP
#line 116 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return keyw (returnkeyw);
            }
            YY_BREAK
        case 25:
            YY_RULE_SETUP
#line 117 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return keyw (typeword);
            }
            YY_BREAK
        case 26:
            YY_RULE_SETUP
#line 118 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return keyw (sizeofop);
            }
            YY_BREAK
        case 27:
            YY_RULE_SETUP
#line 119 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return keyw (storageclass);
            }
            YY_BREAK
        case 28:
            YY_RULE_SETUP
#line 120 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return keyw (structkeyw);
            }
            YY_BREAK
        case 29:
            YY_RULE_SETUP
#line 121 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return keyw (switchkeyw);
            }
            YY_BREAK
        case 30:
            YY_RULE_SETUP
#line 122 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return keyw ((o_duptypedefs) ? typedefkeyw : storageclass);
            }
            YY_BREAK
        case 31:
            YY_RULE_SETUP
#line 123 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return keyw (structkeyw);
            }
            YY_BREAK
        case 32:
            YY_RULE_SETUP
#line 124 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return keyw (typeword);
            }
            YY_BREAK
        case 33:
            YY_RULE_SETUP
#line 125 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return keyw (typeword);
            }
            YY_BREAK
        case 34:
            YY_RULE_SETUP
#line 126 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return keyw (whilekeyw);
            }
            YY_BREAK
        case 35:
            YY_RULE_SETUP
#line 128 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return (o_cplus) ? keyw (typeword) : identif ();
            }
            YY_BREAK
        case 36:
            YY_RULE_SETUP
#line 129 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return (o_cplus) ? keyw (typeword) : identif ();
            }
            YY_BREAK
        case 37:
            YY_RULE_SETUP
#line 130 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return (o_cplus) ? keyw (typeword) : identif ();
            }
            YY_BREAK
        case 38:
            YY_RULE_SETUP
#line 131 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return (o_cplus) ? keyw (typeword) : identif ();
            }
            YY_BREAK
        case 39:
            YY_RULE_SETUP
#line 132 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return (o_cplus) ? keyw (typeword) : identif ();
            }
            YY_BREAK
        case 40:
            YY_RULE_SETUP
#line 134 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return keyw (typequal);
            }
            YY_BREAK
        case 41:
            YY_RULE_SETUP
#line 135 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return keyw (typequal);
            }
            YY_BREAK
        case 42:
            YY_RULE_SETUP
#line 136 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return keyw (typeword);
            }
            YY_BREAK
        case 43:
            YY_RULE_SETUP
#line 137 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return keyw (typequal);
            }
            YY_BREAK
        case 44:
            YY_RULE_SETUP
#line 139 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return keyw (atdefs);
            }
            YY_BREAK
        case 45:
            YY_RULE_SETUP
#line 140 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return keyw (atselector);
            }
            YY_BREAK
        case 46:
            YY_RULE_SETUP
#line 141 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return keyw (atinterface);
            }
            YY_BREAK
        case 47:
            YY_RULE_SETUP
#line 142 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return keyw (atinterface);
            }
            YY_BREAK
        case 48:
            YY_RULE_SETUP
#line 143 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return keyw (atend);
            }
            YY_BREAK
        case 49:
            YY_RULE_SETUP
#line 144 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return keyw (atencode);
            }
            YY_BREAK
        case 50:
            YY_RULE_SETUP
#line 145 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return keyw (typeword);
            }
            YY_BREAK
        case 51:
            YY_RULE_SETUP
#line 146 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return keyw (atrequires);
            }
            YY_BREAK
        case 52:
            YY_RULE_SETUP
#line 147 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                warn ("ignoring @public.");
            }
            YY_BREAK
        case 53:
            YY_RULE_SETUP
#line 148 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return keyw (atproperty);
            }
            YY_BREAK
        case 54:
            YY_RULE_SETUP
#line 149 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                warn ("ignoring @protected.");
            }
            YY_BREAK
        case 55:
            YY_RULE_SETUP
#line 150 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                warn ("ignoring @private.");
            }
            YY_BREAK
        case 56:
            YY_RULE_SETUP
#line 152 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return keyw (storageclass);
            }
            YY_BREAK
        case 57:
            YY_RULE_SETUP
#line 154 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return (o_enableasm) ? keyw (asmkeyw) : identif ();
            }
            YY_BREAK
        case 58:
            /* rule 58 can match eol */
            YY_RULE_SETUP
#line 155 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                yylval = [DosAsmStmt str:yytext];
                return dosasmstmt;
            }
            YY_BREAK
        case 59:
            YY_RULE_SETUP
#line 157 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                yylval = [DosAsmStmt str:yytext];
                return dosasmstmt;
            }
            YY_BREAK
        /* C++ */
        case 60:
            YY_RULE_SETUP
#line 161 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                if (o_cplus)
                    return keyw (namespace);
            }
            YY_BREAK
        case 61:
            YY_RULE_SETUP
#line 162 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                if (o_cplus)
                    return keyw (namespace);
            }
            YY_BREAK
        case 62:
            YY_RULE_SETUP
#line 163 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                if (o_cplus)
                    return keyw (usingkeyw);
            }
            YY_BREAK
        case 63:
            YY_RULE_SETUP
#line 165 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return gnukeyw (typequal);
            }
            YY_BREAK
        case 64:
            YY_RULE_SETUP
#line 166 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return gnukeyw (typequal);
            }
            YY_BREAK
        case 65:
            YY_RULE_SETUP
#line 167 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return gnukeyw (typequal);
            }
            YY_BREAK
        case 66:
            YY_RULE_SETUP
#line 168 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return gnukeyw (typequal);
            }
            YY_BREAK
        case 67:
            YY_RULE_SETUP
#line 169 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return gnukeyw (typequal);
            }
            YY_BREAK
        case 68:
            YY_RULE_SETUP
#line 170 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return gnukeyw (typeword);
            }
            YY_BREAK
        case 69:
            YY_RULE_SETUP
#line 171 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return gnukeyw (typeword);
            }
            YY_BREAK
        case 70:
            YY_RULE_SETUP
#line 172 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return gnukeyw (typeword);
            }
            YY_BREAK
        case 71:
            YY_RULE_SETUP
#line 173 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return gnukeyw (typeword);
            }
            YY_BREAK
        case 72:
            YY_RULE_SETUP
#line 174 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return gnukeyw (attributekeyw);
            }
            YY_BREAK
        case 73:
            YY_RULE_SETUP
#line 175 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return keyw (asmkeyw);
            }
            YY_BREAK
        case 74:
            YY_RULE_SETUP
#line 176 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return keyw (asmkeyw);
            }
            YY_BREAK
        case 75:
            YY_RULE_SETUP
#line 177 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return keyw (storageclass);
            }
            YY_BREAK
        case 76:
            YY_RULE_SETUP
#line 178 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return keyw (storageclass);
            }
            YY_BREAK
        case 77:
            YY_RULE_SETUP
#line 179 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return keyw (storageclass);
            }
            YY_BREAK
        case 78:
            YY_RULE_SETUP
#line 180 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return gnukeyw (gnuextension);
            }
            YY_BREAK
        case 79:
            YY_RULE_SETUP
#line 181 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return gnukeyw (typeofop);
            }
            YY_BREAK
        case 80:
            YY_RULE_SETUP
#line 182 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return gnukeyw (typequal);
            }
            YY_BREAK
        case 81:
            YY_RULE_SETUP
#line 183 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return gnukeyw (typequal);
            }
            YY_BREAK
        case 82:
            YY_RULE_SETUP
#line 185 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return msdoskeyw (typequal);
            }
            YY_BREAK
        case 83:
            YY_RULE_SETUP
#line 186 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return msdoskeyw (typequal);
            }
            YY_BREAK
        case 84:
            YY_RULE_SETUP
#line 187 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return msdoskeyw (typequal);
            }
            YY_BREAK
        case 85:
            YY_RULE_SETUP
#line 188 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return msdoskeyw (typequal);
            }
            YY_BREAK
        case 86:
            YY_RULE_SETUP
#line 189 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return msdoskeyw (typequal);
            }
            YY_BREAK
        case 87:
            YY_RULE_SETUP
#line 190 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return msdoskeyw (typequal);
            }
            YY_BREAK
        case 88:
            YY_RULE_SETUP
#line 191 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return msdoskeyw (typequal);
            }
            YY_BREAK
        case 89:
            YY_RULE_SETUP
#line 192 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return msdoskeyw (typequal);
            }
            YY_BREAK
        case 90:
            YY_RULE_SETUP
#line 193 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return msdoskeyw (typequal);
            }
            YY_BREAK
        case 91:
            YY_RULE_SETUP
#line 194 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return msdoskeyw (typequal);
            }
            YY_BREAK
        case 92:
            YY_RULE_SETUP
#line 195 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return msdoskeyw (typequal);
            }
            YY_BREAK
        case 93:
            YY_RULE_SETUP
#line 196 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return msdoskeyw (typequal);
            }
            YY_BREAK
        case 94:
            YY_RULE_SETUP
#line 197 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return msdoskeyw (typequal);
            }
            YY_BREAK
        case 95:
            YY_RULE_SETUP
#line 198 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return msdoskeyw (typequal);
            }
            YY_BREAK
        case 96:
            YY_RULE_SETUP
#line 199 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return msdoskeyw (typequal);
            }
            YY_BREAK
        case 97:
            YY_RULE_SETUP
#line 200 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return msdoskeyw (typequal);
            }
            YY_BREAK
        case 98:
            YY_RULE_SETUP
#line 202 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                /* SGI IRIX */
                return (o_llkeyw) ? keyw (typeword) : identif ();
            }
            YY_BREAK
        case 99:
            YY_RULE_SETUP
#line 207 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                /* WATCOM C 11 io.h */
                return watcomkeyw (typeword);
            }
            YY_BREAK
        case 100:
            YY_RULE_SETUP
#line 211 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return watcomkeyw (typequal);
            }
            YY_BREAK
        case 101:
            YY_RULE_SETUP
#line 212 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return watcomkeyw (typequal);
            }
            YY_BREAK
        case 102:
            YY_RULE_SETUP
#line 213 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return watcomkeyw (typequal);
            }
            YY_BREAK
        case 103:
            YY_RULE_SETUP
#line 214 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return watcomkeyw (typequal);
            }
            YY_BREAK
        case 104:
            YY_RULE_SETUP
#line 215 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return watcomkeyw (typequal);
            }
            YY_BREAK
        case 105:
            YY_RULE_SETUP
#line 216 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return watcomkeyw (typequal);
            }
            YY_BREAK
        case 106:
            YY_RULE_SETUP
#line 217 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return watcomkeyw (typequal);
            }
            YY_BREAK
        case 107:
            YY_RULE_SETUP
#line 218 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return watcomkeyw (typequal);
            }
            YY_BREAK
        case 108:
            YY_RULE_SETUP
#line 219 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return watcomkeyw (typequal);
            }
            YY_BREAK
        case 109:
            YY_RULE_SETUP
#line 220 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return watcomkeyw (typequal);
            }
            YY_BREAK
        case 110:
            YY_RULE_SETUP
#line 221 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return watcomkeyw (typequal);
            }
            YY_BREAK
        case 111:
            YY_RULE_SETUP
#line 222 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return watcomkeyw (typequal);
            }
            YY_BREAK
        case 112:
            /* rule 112 can match eol */
            YY_RULE_SETUP
#line 223 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return watcomkeyw (typequal);
            }
            YY_BREAK
        case 113:
            /* rule 113 can match eol */
            YY_RULE_SETUP
#line 224 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return watcomkeyw (typequal);
            }
            YY_BREAK
        case 114:
            /* rule 114 can match eol */
            YY_RULE_SETUP
#line 225 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return watcomkeyw (typequal);
            }
            YY_BREAK
        case 115:
            YY_RULE_SETUP
#line 227 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return ibmvackeyw (typequal);
            }
            YY_BREAK
        case 116:
            YY_RULE_SETUP
#line 228 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return ibmvackeyw (typequal);
            }
            YY_BREAK
        case 117:
            YY_RULE_SETUP
#line 229 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return ibmvackeyw (typequal);
            }
            YY_BREAK
        case 118:
            YY_RULE_SETUP
#line 231 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                okblock = 0; /* ({ }) GNU nest block */
                return '(';
            }
            YY_BREAK
        case 119:
            YY_RULE_SETUP
#line 235 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return ')';
            }
            YY_BREAK
        case 120:
            YY_RULE_SETUP
#line 236 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return '[';
            }
            YY_BREAK
        case 121:
            YY_RULE_SETUP
#line 237 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return ']';
            }
            YY_BREAK
        case 122:
            YY_RULE_SETUP
#line 238 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return keyw (arrow);
            }
            YY_BREAK
        case 123:
            YY_RULE_SETUP
#line 239 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return '.';
            }
            YY_BREAK
        case 124:
            YY_RULE_SETUP
#line 240 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return '!';
            }
            YY_BREAK
        case 125:
            YY_RULE_SETUP
#line 241 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return '~';
            }
            YY_BREAK
        case 126:
            YY_RULE_SETUP
#line 242 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return keyw (plusplus);
            }
            YY_BREAK
        case 127:
            YY_RULE_SETUP
#line 243 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return keyw (plusplus);
            }
            YY_BREAK
        case 128:
            YY_RULE_SETUP
#line 244 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return '*';
            }
            YY_BREAK
        case 129:
            YY_RULE_SETUP
#line 245 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return '/';
            }
            YY_BREAK
        case 130:
            YY_RULE_SETUP
#line 246 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return '%';
            }
            YY_BREAK
        case 131:
            YY_RULE_SETUP
#line 247 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return '+';
            }
            YY_BREAK
        case 132:
            YY_RULE_SETUP
#line 248 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return '-';
            }
            YY_BREAK
        case 133:
            YY_RULE_SETUP
#line 249 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return keyw (shift);
            }
            YY_BREAK
        case 134:
            YY_RULE_SETUP
#line 250 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return keyw (shift);
            }
            YY_BREAK
        case 135:
            YY_RULE_SETUP
#line 251 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return keyw (relop);
            }
            YY_BREAK
        case 136:
            YY_RULE_SETUP
#line 252 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return keyw (relop);
            }
            YY_BREAK
        case 137:
            YY_RULE_SETUP
#line 253 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return keyw (relop);
            }
            YY_BREAK
        case 138:
            YY_RULE_SETUP
#line 254 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return keyw (relop);
            }
            YY_BREAK
        case 139:
            YY_RULE_SETUP
#line 255 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return keyw (equalop);
            }
            YY_BREAK
        case 140:
            YY_RULE_SETUP
#line 256 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return keyw (relop);
            }
            YY_BREAK
        case 141:
            YY_RULE_SETUP
#line 257 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return '&';
            }
            YY_BREAK
        case 142:
            YY_RULE_SETUP
#line 258 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return '^';
            }
            YY_BREAK
        case 143:
            YY_RULE_SETUP
#line 259 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return '|';
            }
            YY_BREAK
        case 144:
            YY_RULE_SETUP
#line 260 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return logand;
            }
            YY_BREAK
        case 145:
            YY_RULE_SETUP
#line 261 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return logor;
            }
            YY_BREAK
        case 146:
            YY_RULE_SETUP
#line 262 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return '?';
            }
            YY_BREAK
        case 147:
            YY_RULE_SETUP
#line 263 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return ':';
            }
            YY_BREAK
        case 148:
            YY_RULE_SETUP
#line 264 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return '=';
            }
            YY_BREAK
        case 149:
            YY_RULE_SETUP
#line 265 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return keyw (assignop);
            }
            YY_BREAK
        case 150:
            YY_RULE_SETUP
#line 266 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return keyw (assignop);
            }
            YY_BREAK
        case 151:
            YY_RULE_SETUP
#line 267 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return keyw (assignop);
            }
            YY_BREAK
        case 152:
            YY_RULE_SETUP
#line 268 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return keyw (assignop);
            }
            YY_BREAK
        case 153:
            YY_RULE_SETUP
#line 269 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return keyw (assignop);
            }
            YY_BREAK
        case 154:
            YY_RULE_SETUP
#line 270 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return keyw (assignop);
            }
            YY_BREAK
        case 155:
            YY_RULE_SETUP
#line 271 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return keyw (assignop);
            }
            YY_BREAK
        case 156:
            YY_RULE_SETUP
#line 272 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return keyw (assignop);
            }
            YY_BREAK
        case 157:
            YY_RULE_SETUP
#line 273 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return keyw (assignop);
            }
            YY_BREAK
        case 158:
            YY_RULE_SETUP
#line 274 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return keyw (assignop);
            }
            YY_BREAK
        case 159:
            YY_RULE_SETUP
#line 275 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return ',';
            }
            YY_BREAK
        case 160:
            YY_RULE_SETUP
#line 276 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return ';';
            }
            YY_BREAK
        case 161:
            YY_RULE_SETUP
#line 277 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return keyw ((okblock) ? (okblock = 0, blockbegin) : ('{'));
            }
            YY_BREAK
        case 162:
            YY_RULE_SETUP
#line 278 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return keyw ('}');
            }
            YY_BREAK
        case 163:
            YY_RULE_SETUP
#line 280 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return keyw (ellipsis);
            }
            YY_BREAK
        case 164:
            YY_RULE_SETUP
#line 282 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return keyw (atend); /* ppi */
            }
            YY_BREAK
        case 165:
            YY_RULE_SETUP
#line 284 "/ws/PortableObjectCompiler/objc/lex.lm"
            { /* white space */
                ;
            }
            YY_BREAK
        case 166:
            /* rule 166 can match eol */
            YY_RULE_SETUP
#line 286 "/ws/PortableObjectCompiler/objc/lex.lm"
            { /* newline - keep track of lineno */
                inlineno++;
            }
            YY_BREAK
        case 167:
            /* rule 167 can match eol */
            YY_RULE_SETUP
#line 288 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                /* line directives, such as #, #line, #pragma, #ident */
                yylval = mkcppdirect (yytext);
                if (yylval)
                {
                    inlineno++;
                    return cppdirect;
                }
            }
            YY_BREAK
        case 168:
            YY_RULE_SETUP
#line 294 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return tkeyw (stringcomp, t_str);
            }
            YY_BREAK
        case 169:
            YY_RULE_SETUP
#line 298 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return (o_gnu) ? tkeyw (stringcomp, t_str) : identif ();
            }
            YY_BREAK
        case 170:
            YY_RULE_SETUP
#line 302 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                /* note that we also allow '"' (" is not CCHAR) */
                /* support Macintosh usage 'TEXT' or 'icm#' etc. */
                return tkeyw (constant, t_char);
            }
            YY_BREAK
        case 171:
            YY_RULE_SETUP
#line 308 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return tkeyw (constant, t_int);
            }
            YY_BREAK
        case 172:
            YY_RULE_SETUP
#line 312 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return tkeyw (constant, t_int);
            }
            YY_BREAK
        case 173:
            YY_RULE_SETUP
#line 316 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return tkeyw (constant, t_int);
            }
            YY_BREAK
        case 174:
            YY_RULE_SETUP
#line 320 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return tkeyw (constant, t_double);
            }
            YY_BREAK
        case 175:
            YY_RULE_SETUP
#line 324 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return tkeyw (constant, t_double);
            }
            YY_BREAK
        case 176:
            YY_RULE_SETUP
#line 328 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return tkeyw (constant, t_double);
            }
            YY_BREAK
        case 177:
            YY_RULE_SETUP
#line 332 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                return identif ();
            }
            YY_BREAK
        case 178:
            YY_RULE_SETUP
#line 336 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                /* accept and ignore bcpl style comment */;
            }
            YY_BREAK
        case 179:
            YY_RULE_SETUP
#line 340 "/ws/PortableObjectCompiler/objc/lex.lm"
            {
                if (o_warnlex)
                {
                    char c = (yytext)[0];
                    warn ("lex ignoring '0x%x' (%c)", (int)c, c);
                }
            }
            YY_BREAK
        case 180:
            YY_RULE_SETUP
#line 347 "/ws/PortableObjectCompiler/objc/lex.lm"
            ECHO;
            YY_BREAK
#line 2309 "/ws/PortableObjectCompiler/objc/flex.m"
        case YY_STATE_EOF (INITIAL):
            yyterminate ();

        case YY_END_OF_BUFFER:
        {
            /* Amount of text matched not including the EOB char. */
            int yy_amount_of_matched_text = (int)(yy_cp - (yytext_ptr)) - 1;

            /* Undo the effects of YY_DO_BEFORE_ACTION. */
            *yy_cp = (yy_hold_char);
            YY_RESTORE_YY_MORE_OFFSET

            if (YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW)
            {
                /* We're scanning a new file or input source.  It's
                 * possible that this happened because the user
                 * just pointed yyin at a new source and called
                 * yylex().  If so, then we have to assure
                 * consistency between YY_CURRENT_BUFFER and our
                 * globals.  Here is the right place to do so, because
                 * this is the first action (other than possibly a
                 * back-up) that will match for the new input source.
                 */
                (yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
                YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
                YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
            }

            /* Note that here we test for yy_c_buf_p "<=" to the position
             * of the first EOB in the buffer, since yy_c_buf_p will
             * already have been incremented past the NUL character
             * (since all states make transitions on EOB to the
             * end-of-buffer state).  Contrast this with the test
             * in input().
             */
            if ((yy_c_buf_p) <=
                &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)])
            { /* This was really a NUL. */
                yy_state_type yy_next_state;

                (yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;

                yy_current_state = yy_get_previous_state ();

                /* Okay, we're now positioned to make the NUL
                 * transition.  We couldn't have
                 * yy_get_previous_state() go ahead and do it
                 * for us because it doesn't know how to deal
                 * with the possibility of jamming (and we don't
                 * want to build jamming into it because then it
                 * will run more slowly).
                 */

                yy_next_state = yy_try_NUL_trans (yy_current_state);

                yy_bp = (yytext_ptr) + YY_MORE_ADJ;

                if (yy_next_state)
                {
                    /* Consume the NUL. */
                    yy_cp = ++(yy_c_buf_p);
                    yy_current_state = yy_next_state;
                    goto yy_match;
                }

                else
                {
                    yy_cp = (yy_c_buf_p);
                    goto yy_find_action;
                }
            }

            else
                switch (yy_get_next_buffer ())
                {
                case EOB_ACT_END_OF_FILE:
                {
                    (yy_did_buffer_switch_on_eof) = 0;

                    if (yywrap ())
                    {
                        /* Note: because we've taken care in
                         * yy_get_next_buffer() to have set up
                         * yytext, we can now set up
                         * yy_c_buf_p so that if some total
                         * hoser (like flex itself) wants to
                         * call the scanner after we return the
                         * YY_NULL, it'll still work - another
                         * YY_NULL will get returned.
                         */
                        (yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;

                        yy_act = YY_STATE_EOF (YY_START);
                        goto do_action;
                    }

                    else
                    {
                        if (!(yy_did_buffer_switch_on_eof))
                            YY_NEW_FILE;
                    }
                    break;
                }

                case EOB_ACT_CONTINUE_SCAN:
                    (yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;

                    yy_current_state = yy_get_previous_state ();

                    yy_cp = (yy_c_buf_p);
                    yy_bp = (yytext_ptr) + YY_MORE_ADJ;
                    goto yy_match;

                case EOB_ACT_LAST_MATCH:
                    (yy_c_buf_p) =
                        &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];

                    yy_current_state = yy_get_previous_state ();

                    yy_cp = (yy_c_buf_p);
                    yy_bp = (yytext_ptr) + YY_MORE_ADJ;
                    goto yy_find_action;
                }
            break;
        }

        default:
            YY_FATAL_ERROR (
                "fatal flex scanner internal error--no action found");
        } /* end of action switch */
    }     /* end of scanning one token */
} /* end of yylex */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *	EOB_ACT_LAST_MATCH -
 *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *	EOB_ACT_END_OF_FILE - end of file
 */
static int yy_get_next_buffer (void)
{
    char * dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
    char * source = (yytext_ptr);
    int number_to_move, i;
    int ret_val;

    if ((yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1])
        YY_FATAL_ERROR (
            "fatal flex scanner internal error--end of buffer missed");

    if (YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0)
    { /* Don't try to fill the buffer, so this is an EOF. */
        if ((yy_c_buf_p) - (yytext_ptr)-YY_MORE_ADJ == 1)
        {
            /* We matched a single character, the EOB, so
             * treat this as a final EOF.
             */
            return EOB_ACT_END_OF_FILE;
        }

        else
        {
            /* We matched some text prior to the EOB, first
             * process it.
             */
            return EOB_ACT_LAST_MATCH;
        }
    }

    /* Try to read more data. */

    /* First move last chars to start of buffer. */
    number_to_move = (int)((yy_c_buf_p) - (yytext_ptr)) - 1;

    for (i = 0; i < number_to_move; ++i)
        *(dest++) = *(source++);

    if (YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING)
        /* don't do the read, it's not guaranteed to return an EOF,
         * just force an EOF
         */
        YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;

    else
    {
        yy_size_t num_to_read =
            YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

        while (num_to_read <= 0)
        { /* Not enough room in the buffer - grow it. */

            /* just a shorter name for the current buffer */
            YY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;

            int yy_c_buf_p_offset = (int)((yy_c_buf_p)-b->yy_ch_buf);

            if (b->yy_is_our_buffer)
            {
                yy_size_t new_size = b->yy_buf_size * 2;

                if (new_size <= 0)
                    b->yy_buf_size += b->yy_buf_size / 8;
                else
                    b->yy_buf_size *= 2;

                b->yy_ch_buf = (char *)
                    /* Include room in for 2 EOB chars. */
                    yyrealloc ((void *)b->yy_ch_buf, b->yy_buf_size + 2);
            }
            else
                /* Can't grow it, we don't own it. */
                b->yy_ch_buf = 0;

            if (!b->yy_ch_buf)
                YY_FATAL_ERROR ("fatal error - scanner input buffer overflow");

            (yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];

            num_to_read =
                YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
        }

        if (num_to_read > YY_READ_BUF_SIZE)
            num_to_read = YY_READ_BUF_SIZE;

        /* Read in more data. */
        YY_INPUT ((&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
                  (yy_n_chars), num_to_read);

        YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
    }

    if ((yy_n_chars) == 0)
    {
        if (number_to_move == YY_MORE_ADJ)
        {
            ret_val = EOB_ACT_END_OF_FILE;
            yyrestart (yyin);
        }

        else
        {
            ret_val = EOB_ACT_LAST_MATCH;
            YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_EOF_PENDING;
        }
    }

    else
        ret_val = EOB_ACT_CONTINUE_SCAN;

    if ((yy_size_t) ((yy_n_chars) + number_to_move) >
        YY_CURRENT_BUFFER_LVALUE->yy_buf_size)
    {
        /* Extend the array by 50%, plus the number we really need. */
        yy_size_t new_size =
            (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
        YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *)yyrealloc (
            (void *)YY_CURRENT_BUFFER_LVALUE->yy_ch_buf, new_size);
        if (!YY_CURRENT_BUFFER_LVALUE->yy_ch_buf)
            YY_FATAL_ERROR ("out of dynamic memory in yy_get_next_buffer()");
    }

    (yy_n_chars) += number_to_move;
    YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
    YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] =
        YY_END_OF_BUFFER_CHAR;

    (yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

    return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was reached */

static yy_state_type yy_get_previous_state (void)
{
    yy_state_type yy_current_state;
    char * yy_cp;

    yy_current_state = (yy_start);

    for (yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp)
    {
        YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI (*yy_cp)] : 1);
        if (yy_accept[yy_current_state])
        {
            (yy_last_accepting_state) = yy_current_state;
            (yy_last_accepting_cpos) = yy_cp;
        }
        while (yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state)
        {
            yy_current_state = (int)yy_def[yy_current_state];
            if (yy_current_state >= 748)
                yy_c = yy_meta[(unsigned int)yy_c];
        }
        yy_current_state =
            yy_nxt[yy_base[yy_current_state] + (unsigned int)yy_c];
    }

    return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *	next_state = yy_try_NUL_trans( current_state );
 */
static yy_state_type yy_try_NUL_trans (yy_state_type yy_current_state)
{
    int yy_is_jam;
    char * yy_cp = (yy_c_buf_p);

    YY_CHAR yy_c = 1;
    if (yy_accept[yy_current_state])
    {
        (yy_last_accepting_state) = yy_current_state;
        (yy_last_accepting_cpos) = yy_cp;
    }
    while (yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state)
    {
        yy_current_state = (int)yy_def[yy_current_state];
        if (yy_current_state >= 748)
            yy_c = yy_meta[(unsigned int)yy_c];
    }
    yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int)yy_c];
    yy_is_jam = (yy_current_state == 747);

    return yy_is_jam ? 0 : yy_current_state;
}

#ifndef YY_NO_UNPUT
static void yyunput (int c, char * yy_bp)
{
    char * yy_cp;

    yy_cp = (yy_c_buf_p);

    /* undo effects of setting up yytext */
    *yy_cp = (yy_hold_char);

    if (yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2)
    { /* need to shift things up to make room */
        /* +2 for EOB chars. */
        yy_size_t number_to_move = (yy_n_chars) + 2;
        char * dest =
            &YY_CURRENT_BUFFER_LVALUE
                 ->yy_ch_buf[YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
        char * source = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];

        while (source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf)
            *--dest = *--source;

        yy_cp += (int)(dest - source);
        yy_bp += (int)(dest - source);
        YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) =
            YY_CURRENT_BUFFER_LVALUE->yy_buf_size;

        if (yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2)
            YY_FATAL_ERROR ("flex scanner push-back overflow");
    }

    *--yy_cp = (char)c;

    (yytext_ptr) = yy_bp;
    (yy_hold_char) = *yy_cp;
    (yy_c_buf_p) = yy_cp;
}
#endif /* ifndef YY_NO_UNPUT */

#ifndef YY_NO_INPUT
#ifdef __cplusplus
static int yyinput (void)
#else
static int input (void)
#endif

{
    int c;

    *(yy_c_buf_p) = (yy_hold_char);

    if (*(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR)
    {
        /* yy_c_buf_p now points to the character we want to return.
         * If this occurs *before* the EOB characters, then it's a
         * valid NUL; if not, then we've hit the end of the buffer.
         */
        if ((yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)])
            /* This was really a NUL. */
            *(yy_c_buf_p) = '\0';

        else
        { /* need more input */
            yy_size_t offset = (yy_c_buf_p) - (yytext_ptr);
            ++(yy_c_buf_p);

            switch (yy_get_next_buffer ())
            {
            case EOB_ACT_LAST_MATCH:
                /* This happens because yy_g_n_b()
                 * sees that we've accumulated a
                 * token and flags that we need to
                 * try matching the token before
                 * proceeding.  But for input(),
                 * there's no matching to consider.
                 * So convert the EOB_ACT_LAST_MATCH
                 * to EOB_ACT_END_OF_FILE.
                 */

                /* Reset buffer status. */
                yyrestart (yyin);

            /*FALLTHROUGH*/

            case EOB_ACT_END_OF_FILE:
            {
                if (yywrap ())
                    return EOF;

                if (!(yy_did_buffer_switch_on_eof))
                    YY_NEW_FILE;
#ifdef __cplusplus
                return yyinput ();
#else
                return input ();
#endif
            }

            case EOB_ACT_CONTINUE_SCAN:
                (yy_c_buf_p) = (yytext_ptr) + offset;
                break;
            }
        }
    }

    c = *(unsigned char *)(yy_c_buf_p); /* cast for 8-bit char's */
    *(yy_c_buf_p) = '\0';               /* preserve yytext */
    (yy_hold_char) = *++(yy_c_buf_p);

    return c;
}
#endif /* ifndef YY_NO_INPUT */

/** Immediately switch to a different input stream.
 * @param input_file A readable stream.
 *
 * @note This function does not reset the start condition to @c INITIAL .
 */
void yyrestart (FILE * input_file)
{

    if (!YY_CURRENT_BUFFER)
    {
        yyensure_buffer_stack ();
        YY_CURRENT_BUFFER_LVALUE = yy_create_buffer (yyin, YY_BUF_SIZE);
    }

    yy_init_buffer (YY_CURRENT_BUFFER, input_file);
    yy_load_buffer_state ();
}

/** Switch to a different input buffer.
 * @param new_buffer The new input buffer.
 *
 */
void yy_switch_to_buffer (YY_BUFFER_STATE new_buffer)
{

    /* TODO. We should be able to replace this entire function body
     * with
     *		yypop_buffer_state();
     *		yypush_buffer_state(new_buffer);
     */
    yyensure_buffer_stack ();
    if (YY_CURRENT_BUFFER == new_buffer)
        return;

    if (YY_CURRENT_BUFFER)
    {
        /* Flush out information for old buffer. */
        *(yy_c_buf_p) = (yy_hold_char);
        YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
        YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
    }

    YY_CURRENT_BUFFER_LVALUE = new_buffer;
    yy_load_buffer_state ();

    /* We don't actually know whether we did this switch during
     * EOF (yywrap()) processing, but the only time this flag
     * is looked at is after yywrap() is called, so it's safe
     * to go ahead and always set it.
     */
    (yy_did_buffer_switch_on_eof) = 1;
}

static void yy_load_buffer_state (void)
{
    (yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
    (yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
    yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
    (yy_hold_char) = *(yy_c_buf_p);
}

/** Allocate and initialize an input buffer state.
 * @param file A readable stream.
 * @param size The character buffer size in bytes. When in doubt, use @c
 * YY_BUF_SIZE.
 *
 * @return the allocated buffer state.
 */
YY_BUFFER_STATE yy_create_buffer (FILE * file, int size)
{
    YY_BUFFER_STATE b;

    b = (YY_BUFFER_STATE)yyalloc (sizeof (struct yy_buffer_state));
    if (!b)
        YY_FATAL_ERROR ("out of dynamic memory in yy_create_buffer()");

    b->yy_buf_size = size;

    /* yy_ch_buf has to be 2 characters longer than the size given because
     * we need to put in 2 end-of-buffer characters.
     */
    b->yy_ch_buf = (char *)yyalloc (b->yy_buf_size + 2);
    if (!b->yy_ch_buf)
        YY_FATAL_ERROR ("out of dynamic memory in yy_create_buffer()");

    b->yy_is_our_buffer = 1;

    yy_init_buffer (b, file);

    return b;
}

/** Destroy the buffer.
 * @param b a buffer created with yy_create_buffer()
 *
 */
void yy_delete_buffer (YY_BUFFER_STATE b)
{

    if (!b)
        return;

    if (b == YY_CURRENT_BUFFER) /* Not sure if we should pop here. */
        YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE)0;

    if (b->yy_is_our_buffer)
        yyfree ((void *)b->yy_ch_buf);

    yyfree ((void *)b);
}

/* Initializes or reinitializes a buffer.
 * This function is sometimes called more than once on the same buffer,
 * such as during a yyrestart() or at EOF.
 */
static void yy_init_buffer (YY_BUFFER_STATE b, FILE * file)

{
    int oerrno = errno;

    yy_flush_buffer (b);

    b->yy_input_file = file;
    b->yy_fill_buffer = 1;

    /* If b is the current buffer, then yy_init_buffer was _probably_
     * called from yyrestart() or through yy_get_next_buffer.
     * In that case, we don't want to reset the lineno or column.
     */
    if (b != YY_CURRENT_BUFFER)
    {
        b->yy_bs_lineno = 1;
        b->yy_bs_column = 0;
    }

    b->yy_is_interactive = file ? (isatty (fileno (file)) > 0) : 0;

    errno = oerrno;
}

/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
 * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
 *
 */
void yy_flush_buffer (YY_BUFFER_STATE b)
{
    if (!b)
        return;

    b->yy_n_chars = 0;

    /* We always need two end-of-buffer characters.  The first causes
     * a transition to the end-of-buffer state.  The second causes
     * a jam in that state.
     */
    b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
    b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;

    b->yy_buf_pos = &b->yy_ch_buf[0];

    b->yy_at_bol = 1;
    b->yy_buffer_status = YY_BUFFER_NEW;

    if (b == YY_CURRENT_BUFFER)
        yy_load_buffer_state ();
}

/** Pushes the new state onto the stack. The new state becomes
 *  the current state. This function will allocate the stack
 *  if necessary.
 *  @param new_buffer The new state.
 *
 */
void yypush_buffer_state (YY_BUFFER_STATE new_buffer)
{
    if (new_buffer == NULL)
        return;

    yyensure_buffer_stack ();

    /* This block is copied from yy_switch_to_buffer. */
    if (YY_CURRENT_BUFFER)
    {
        /* Flush out information for old buffer. */
        *(yy_c_buf_p) = (yy_hold_char);
        YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
        YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
    }

    /* Only push if top exists. Otherwise, replace top. */
    if (YY_CURRENT_BUFFER)
        (yy_buffer_stack_top)++;
    YY_CURRENT_BUFFER_LVALUE = new_buffer;

    /* copied from yy_switch_to_buffer. */
    yy_load_buffer_state ();
    (yy_did_buffer_switch_on_eof) = 1;
}

/** Removes and deletes the top of the stack, if present.
 *  The next element becomes the new top.
 *
 */
void yypop_buffer_state (void)
{
    if (!YY_CURRENT_BUFFER)
        return;

    yy_delete_buffer (YY_CURRENT_BUFFER);
    YY_CURRENT_BUFFER_LVALUE = NULL;
    if ((yy_buffer_stack_top) > 0)
        --(yy_buffer_stack_top);

    if (YY_CURRENT_BUFFER)
    {
        yy_load_buffer_state ();
        (yy_did_buffer_switch_on_eof) = 1;
    }
}

/* Allocates the stack if it does not exist.
 *  Guarantees space for at least one push.
 */
static void yyensure_buffer_stack (void)
{
    yy_size_t num_to_alloc;

    if (!(yy_buffer_stack))
    {

        /* First allocation is just for 2 elements, since we don't know if this
         * scanner will even need a stack. We use 2 instead of 1 to avoid an
         * immediate realloc on the next call.
         */
        num_to_alloc = 1;
        (yy_buffer_stack) = (struct yy_buffer_state **)yyalloc (
            num_to_alloc * sizeof (struct yy_buffer_state *));
        if (!(yy_buffer_stack))
            YY_FATAL_ERROR ("out of dynamic memory in yyensure_buffer_stack()");

        memset ((yy_buffer_stack), 0,
                num_to_alloc * sizeof (struct yy_buffer_state *));

        (yy_buffer_stack_max) = num_to_alloc;
        (yy_buffer_stack_top) = 0;
        return;
    }

    if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1)
    {

        /* Increase the buffer to prepare for a possible push. */
        int grow_size = 8 /* arbitrary grow size */;

        num_to_alloc = (yy_buffer_stack_max) + grow_size;
        (yy_buffer_stack) = (struct yy_buffer_state **)yyrealloc (
            (yy_buffer_stack),
            num_to_alloc * sizeof (struct yy_buffer_state *));
        if (!(yy_buffer_stack))
            YY_FATAL_ERROR ("out of dynamic memory in yyensure_buffer_stack()");

        /* zero only the new slots.*/
        memset ((yy_buffer_stack) + (yy_buffer_stack_max), 0,
                grow_size * sizeof (struct yy_buffer_state *));
        (yy_buffer_stack_max) = num_to_alloc;
    }
}

/** Setup the input buffer state to scan directly from a user-specified
 * character buffer.
 * @param base the character buffer
 * @param size the size in bytes of the character buffer
 *
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE yy_scan_buffer (char * base, yy_size_t size)
{
    YY_BUFFER_STATE b;

    if (size < 2 || base[size - 2] != YY_END_OF_BUFFER_CHAR ||
        base[size - 1] != YY_END_OF_BUFFER_CHAR)
        /* They forgot to leave room for the EOB's. */
        return 0;

    b = (YY_BUFFER_STATE)yyalloc (sizeof (struct yy_buffer_state));
    if (!b)
        YY_FATAL_ERROR ("out of dynamic memory in yy_scan_buffer()");

    b->yy_buf_size = size - 2; /* "- 2" to take care of EOB's */
    b->yy_buf_pos = b->yy_ch_buf = base;
    b->yy_is_our_buffer = 0;
    b->yy_input_file = 0;
    b->yy_n_chars = b->yy_buf_size;
    b->yy_is_interactive = 0;
    b->yy_at_bol = 1;
    b->yy_fill_buffer = 0;
    b->yy_buffer_status = YY_BUFFER_NEW;

    yy_switch_to_buffer (b);

    return b;
}

/** Setup the input buffer state to scan a string. The next call to yylex() will
 * scan from a @e copy of @a str.
 * @param yystr a NUL-terminated string to scan
 *
 * @return the newly allocated buffer state object.
 * @note If you want to scan bytes that may contain NUL values, then use
 *       yy_scan_bytes() instead.
 */
YY_BUFFER_STATE yy_scan_string (yyconst char * yystr)
{

    return yy_scan_bytes (yystr, strlen (yystr));
}

/** Setup the input buffer state to scan the given bytes. The next call to
 * yylex() will
 * scan from a @e copy of @a bytes.
 * @param yybytes the byte buffer to scan
 * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
 *
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE yy_scan_bytes (yyconst char * yybytes, yy_size_t _yybytes_len)
{
    YY_BUFFER_STATE b;
    char * buf;
    yy_size_t n;
    yy_size_t i;

    /* Get memory for full buffer, including space for trailing EOB's. */
    n = _yybytes_len + 2;
    buf = (char *)yyalloc (n);
    if (!buf)
        YY_FATAL_ERROR ("out of dynamic memory in yy_scan_bytes()");

    for (i = 0; i < _yybytes_len; ++i)
        buf[i] = yybytes[i];

    buf[_yybytes_len] = buf[_yybytes_len + 1] = YY_END_OF_BUFFER_CHAR;

    b = yy_scan_buffer (buf, n);
    if (!b)
        YY_FATAL_ERROR ("bad buffer in yy_scan_bytes()");

    /* It's okay to grow etc. this buffer, and we should throw it
     * away when we're done.
     */
    b->yy_is_our_buffer = 1;

    return b;
}

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

static void yy_fatal_error (yyconst char * msg)
{
    (void)fprintf (stderr, "%s\n", msg);
    exit (YY_EXIT_FAILURE);
}

/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n)                                                              \
    do                                                                         \
    {                                                                          \
        /* Undo effects of setting up yytext. */                               \
        int yyless_macro_arg = (n);                                            \
        YY_LESS_LINENO (yyless_macro_arg);                                     \
        yytext[yyleng] = (yy_hold_char);                                       \
        (yy_c_buf_p) = yytext + yyless_macro_arg;                              \
        (yy_hold_char) = *(yy_c_buf_p);                                        \
        *(yy_c_buf_p) = '\0';                                                  \
        yyleng = yyless_macro_arg;                                             \
    } while (0)

/* Accessor  methods (get/set functions) to struct members. */

/** Get the current line number.
 *
 */
int yyget_lineno (void) { return yylineno; }

/** Get the input stream.
 *
 */
FILE * yyget_in (void) { return yyin; }

/** Get the output stream.
 *
 */
FILE * yyget_out (void) { return yyout; }

/** Get the length of the current token.
 *
 */
yy_size_t yyget_leng (void) { return yyleng; }

/** Get the current token.
 *
 */

char * yyget_text (void) { return yytext; }

/** Set the current line number.
 * @param line_number
 *
 */
void yyset_lineno (int line_number) { yylineno = line_number; }

/** Set the input stream. This does not discard the current
 * input buffer.
 * @param in_str A readable stream.
 *
 * @see yy_switch_to_buffer
 */
void yyset_in (FILE * in_str) { yyin = in_str; }

void yyset_out (FILE * out_str) { yyout = out_str; }

int yyget_debug (void) { return yy_flex_debug; }

void yyset_debug (int bdebug) { yy_flex_debug = bdebug; }

static int yy_init_globals (void)
{
    /* Initialization is the same as for the non-reentrant scanner.
 * This function is called from yylex_destroy(), so don't allocate here.
 */

    (yy_buffer_stack) = 0;
    (yy_buffer_stack_top) = 0;
    (yy_buffer_stack_max) = 0;
    (yy_c_buf_p) = (char *)0;
    (yy_init) = 0;
    (yy_start) = 0;

/* Defined in main.c */
#ifdef YY_STDINIT
    yyin = stdin;
    yyout = stdout;
#else
    yyin = (FILE *)0;
    yyout = (FILE *)0;
#endif

    /* For future reference: Set errno on error, since we are called by
     * yylex_init()
     */
    return 0;
}

/* yylex_destroy is for both reentrant and non-reentrant scanners. */
int yylex_destroy (void)
{

    /* Pop the buffer stack, destroying each element. */
    while (YY_CURRENT_BUFFER)
    {
        yy_delete_buffer (YY_CURRENT_BUFFER);
        YY_CURRENT_BUFFER_LVALUE = NULL;
        yypop_buffer_state ();
    }

    /* Destroy the stack itself. */
    yyfree ((yy_buffer_stack));
    (yy_buffer_stack) = NULL;

    /* Reset the globals. This is important in a non-reentrant scanner so the
     * next time
     * yylex() is called, initialization will occur. */
    yy_init_globals ();

    return 0;
}

/*
 * Internal utility routines.
 */

#ifndef yytext_ptr
static void yy_flex_strncpy (char * s1, yyconst char * s2, int n)
{
    int i;
    for (i = 0; i < n; ++i)
        s1[i] = s2[i];
}
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen (yyconst char * s)
{
    int n;
    for (n = 0; s[n]; ++n)
        ;

    return n;
}
#endif

void * yyalloc (yy_size_t size) { return (void *)malloc (size); }

void * yyrealloc (void * ptr, yy_size_t size)
{
    /* The cast to (char *) in the following accommodates both
     * implementations that use char* generic pointers, and those
     * that use void* generic pointers.  It works with the latter
     * because both ANSI C and C++ allow castless assignment from
     * any pointer type to void*, and deal with argument conversions
     * as though doing an assignment.
     */
    return (void *)realloc ((char *)ptr, size);
}

void yyfree (void * ptr)
{
    free ((char *)ptr); /* see yyrealloc() for (char *) cast */
}

#define YYTABLES_NAME "yytables"

#line 347 "/ws/PortableObjectCompiler/objc/lex.lm"

/*
 * Put this in the routines section rather than the definitions section.
 * Old flex versions don't define 'yytext' before rules section.
 */

void yyerror (char * str) { fatal ("%s \"%s\"", str, yytext); }

/* some flex defines it as 1 */

#ifndef yywrap
int yywrap () { return 1; }
#endif

int identif (void)
{
    yylval = [Symbol str:yytext lineno:inlineno filename:infilename];
    if (!o_duptypedefs)
    {
        if (isbuiltinfun (yylval))
            return builtinfun;
        if (istypeword (yylval))
            return typeword;
    }
    return identifier;
}

int keyw (int x)
{
    if (x == storageclass || x == typedefkeyw || x == externlang ||
        x == gnuextension)
    {
        yylval = [Storageclass str:yytext lineno:inlineno filename:infilename];
    }
    else
    {
        yylval = [Symbol str:yytext lineno:inlineno filename:infilename];
    }
    return x;
}

int tkeyw (int x, id t)
{
    yylval = [Symbol str:yytext lineno:inlineno filename:infilename];
    [yylval type:t];
    return x;
}

int gnukeyw (int x) { return (o_gnu) ? keyw (x) : identif (); }

int msdoskeyw (int x) { return (o_msdos) ? keyw (x) : identif (); }

int watcomkeyw (int x) { return (o_watcom) ? keyw (x) : identif (); }

int ibmvackeyw (int x) { return (o_ibmvac) ? keyw (x) : identif (); }
