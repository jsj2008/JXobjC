<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ascii">
<title>sortcltn Specification Sheet</title>
</head>
<body>
<h1>sortcltn Specification Sheet</h1>

<hr>
Portable Object Compiler (c) 1997,98,2003.  All Rights Reserved.<p>
</p>
<h1>SortCltn</h1>
<b>Inherits from:</b> Cltn<p>
</p>
<h2>Class Description</h2>
<b>SortCltn</b> (alias <b>SortedCollection</b>) instances are groups of objects that are kept in sorted order in a tree (by default, the first object is the smallest with respect to <b>compare:</b>).  Inserting and searching objects in such a sorted collection can be faster than using, say an <b>OrdCltn</b> object collection.<p>
</p>
<h2>Creating An Instance</h2>
The method <b>new</b> creates an instance that sorts its elements with respect to <b>compare:</b>.  The method <b>newDictCompare</b> sends <b>dictCompare:</b> messages to compare pairs of elements.  Finally, the method <b>sortBy::</b> creates a SortCltn that will sort its contents with respect to an arbitrary Block.<p>
</p>
<h2>Adding Objects</h2>
Normally, you insert an object with the <b>add:</b> method.  This method allows you to add an object to the collection, even when it is equal to an element in the collection (when the comparison method returns zero; because you can use a different method than <b>compare:</b>, this doesn't necessarily mean that <b>isEqual:</b> returns YES).<p>
You can also choose not to add duplicate entries.  The <b>addNTest:</b> method adds if the object was absent and returns a value that can be used to test whether the object was found or not. The <b>filter:</b> method frees a new entry when it's a duplicate.  The <b>replace:</b> method always replaces duplicates (returning the object that was previously in the collection).</p>
<p>
</p>
<h2>Sorting collections </h2>
One use of <b>SortCltn</b> instances, is to sort collections of objects.  For example,<p>
</p>
<blockquote><pre>
aSortCltn = [[SortCltn new] addAll:aCltn];
</pre></blockquote>
will sequence of the contents of <i>aCltn</i> and will add the members of the collection to a new SortCltn instance.  This is equivalent to sorting the collection.  To obtain a sorted <b>OrdCltn</b> instance (as opposed to a <b>SortCltn</b>), simply convert back like this,<p>
</p>
<blockquote><pre>
aCltn = [[OrdCltn new] addAll:aSortCltn];
</pre></blockquote>
To filter out duplicate entries, it's also possible to insert a Set instance in the conversion process.<p>
</p>
<h2>Method types</h2>
<h3><b>Creation</b></h3>
<ul>
<li><a href="#0">new</a></li>
<li><a href="#1">new:</a></li>
<li><a href="#2">newDictCompare</a></li>
<li><a href="#4">sortBy:</a></li>
<li><a href="#5">sortBlock:</a></li>
<li><a href="#7">newCmpSel:</a></li>
<li><a href="#31">with:</a></li>
<li><a href="#32">with:with:</a></li>
<li><a href="#33">add:</a></li>
<li><a href="#8">copy</a></li>
<li><a href="#9">deepCopy</a></li>
<li><a href="#10">emptyYourself</a></li>
<li><a href="#11">freeContents</a></li>
<li><a href="#12">free</a></li>
</ul>
<h3><b>Interrogation</b></h3>
<ul>
<li><a href="#16">size</a></li>
<li><a href="#17">isEmpty</a></li>
<li><a href="#18">eachElement</a></li>
</ul>
<h3><b>Comparing</b></h3>
<ul>
<li><a href="#19">hash</a></li>
<li><a href="#20">isEqual:</a></li>
</ul>
<h3><b>Adding</b></h3>
<ul>
<li><a href="#21">add:</a></li>
<li><a href="#22">addNTest:</a></li>
<li><a href="#23">filter:</a></li>
<li><a href="#24">replace:</a></li>
</ul>
<h3><b>Removing</b></h3>
<ul>
<li><a href="#25">remove:</a></li>
</ul>
<h3><b>Testing Contents</b></h3>
<ul>
<li><a href="#34">includesAllOf:</a></li>
<li><a href="#35">includesAnyOf:</a></li>
</ul>
<h3><b>Adding and Removing Contents</b></h3>
<ul>
<li><a href="#36">addAll:</a></li>
<li><a href="#37">addContentsOf:</a></li>
<li><a href="#38">addContentsTo:</a></li>
<li><a href="#39">removeAll:</a></li>
<li><a href="#40">removeContentsFrom:</a></li>
<li><a href="#41">removeContentsOf:</a></li>
</ul>
<h3><b>Combining</b></h3>
<ul>
<li><a href="#42">intersection:</a></li>
<li><a href="#43">union:</a></li>
<li><a href="#44">difference:</a></li>
</ul>
<h3><b>Converting</b></h3>
<ul>
<li><a href="#45">asSet</a></li>
<li><a href="#46">asOrdCltn</a></li>
</ul>
<h3><b>Using Blocks</b></h3>
<ul>
<li><a href="#47">detect:</a></li>
<li><a href="#48">detect:ifNone:</a></li>
<li><a href="#49">select:</a></li>
<li><a href="#50">reject:</a></li>
<li><a href="#51">collect:</a></li>
<li><a href="#52">count:</a></li>
</ul>
<h3><b>Making elements perform</b></h3>
<ul>
<li><a href="#53">elementsPerform:</a></li>
<li><a href="#54">elementsPerform:with:</a></li>
<li><a href="#55">elementsPerform:with:with:</a></li>
<li><a href="#56">elementsPerform:with:with:with:</a></li>
</ul>
<h3><b>Do Blocks</b></h3>
<ul>
<li><a href="#57">do:</a></li>
<li><a href="#58">do:until:</a></li>
</ul>
<h3><b>Locating</b></h3>
<ul>
<li><a href="#26">find:</a></li>
<li><a href="#27">contains:</a></li>
</ul>
<h3><b>Printing</b></h3>
<ul>
<li><a href="#28">printOn:</a></li>
</ul>
<h3><b>Archiving</b></h3>
<ul>
<li><a href="#29">fileOutOn:</a></li>
<li><a href="#30">fileInFrom:</a></li>
</ul>
<h2>Methods</h2>
<h3><a name="0">new</a></h3>
<blockquote>+<b>new</b>
</blockquote>
Returns a new instance that sorts its contents with respect to <b>compare:</b>.<p>
</p>
<h3><a name="1">new:</a></h3>
<blockquote>+<b>new</b>:(unsigned)<i>n</i>
</blockquote>
For this class, this method does not differ from <b>new</b>.<p>
</p>
<h3><a name="2">newDictCompare</a></h3>
<blockquote>+<b>newDictCompare</b>
</blockquote>
Returns a new instance that sorts its contents with respect to <b>dictCompare:</b>.<p>
</p>
<h3><a name="4">sortBy:</a></h3>
<blockquote>+<b>sortBy</b>:<i>sortBlock</i>
</blockquote>
Returns a new instance that sorts its contents with respect to <i>sortBlock</i>.  This block should take two objects <i>a</i> and <i>b</i> as argument, and return a positive value if <i>a</i> is greater than <i>b</i>, or zero if <i>a</i> and <i>b</i> are equal, and a negative value if <i>a</i> is less than <i>b</i>.<p>
</p>
<blockquote><pre>
id c;
int r;
c = [SortCltn sortBy:{ :a:b | [a compare:b] }];
</pre></blockquote>
<h3><a name="5">sortBlock:</a></h3>
<blockquote>+<b>sortBlock</b>:<i>sortBlock</i>
</blockquote>
Same as <b>sortBy:</b>.<p>
<b>Note:</b> There is a SortedCollection method with a similar name in <i>Squeak</i>.</p>
<p>
</p>
<h3><a name="7">newCmpSel:</a></h3>
<blockquote>+<b>newCmpSel</b>:(SEL)<i>aSel</i>
</blockquote>
For backwards compatibility only.  <b>sortBy:</b> provides a more powerful mechanism to sort given an arbitrary sort block.<p>
</p>
<h3><a name="31">with:</a></h3>
<blockquote>+<b>with</b>:(int)<i>nArgs,...</i>
</blockquote>
Returns a new object with <i>nArgs</i> elements.  For example,<p>
</p>
<blockquote><pre>
id aCltn = [OrdCltn with:2,anObject,otherObject];
</pre></blockquote>
creates a collection and adds <i>anObject</i> and <i>otherObject</i> to it.  In a similar way, <b>Set</b> or <b>SortCltn</b> instances can be created like this.<p>
</p>
<h3><a name="32">with:with:</a></h3>
<blockquote>+<b>with</b>:<i>firstObject</i><b>with</b>:<i>nextObject</i>
</blockquote>
This method is equivalent to <b>with:</b> 2,<i>firstObject</i>,<i>nextObject</i>. <p>
</p>
<h3><a name="33">add:</a></h3>
<blockquote>+<b>add</b>:<i>firstObject</i>
</blockquote>
This method is equivalent to <b>with:</b> 1,<i>firstObject</i>. <p>
This (factory) method has the same name as the instance method <b>add:</b> and can be used as follows, in circumstances when the user does not want to allocate a collection unless it is actually used :</p>
<p>
</p>
<blockquote><pre>
aCltn = [ (aCltn)?aCltn:OrdCltn add:myObject ];
</pre></blockquote>
This shows that creation of the collection is delayed until it is actually needed.  If the collection already exists, objects are simply added, using the instance method <b>add:</b>.<p>
</p>
<h3><a name="8">copy</a></h3>
<blockquote>-<b>copy</b>
</blockquote>
Returns a new copy of the object (without copying the elements).<p>
</p>
<h3><a name="9">deepCopy</a></h3>
<blockquote>-<b>deepCopy</b>
</blockquote>
Returns a new copy of the object.  The elements in the new copy are deep copies of the elements in the original object.<p>
</p>
<h3><a name="10">emptyYourself</a></h3>
<blockquote>-<b>emptyYourself</b>
</blockquote>
Empties all the members of the object (without freeing them).  Returns the receiver.<p>
</p>
<h3><a name="11">freeContents</a></h3>
<blockquote>-<b>freeContents</b>
</blockquote>
Removes and frees the contents of the object, but doesn't free the object itself.  Returns the receiver.<p>
</p>
<h3><a name="12">free</a></h3>
<blockquote>-<b>free</b>
</blockquote>
Frees the object, but not its contents.  Returns <b>nil</b>.  Do :<p>
</p>
<blockquote><pre>
aSort = [[aSort freeContents] free];
</pre></blockquote>
if you want to free the object and its contents.<p>
</p>
<h3><a name="16">size</a></h3>
<blockquote>- (unsigned)<b>size</b>
</blockquote>
Returns the number of elements in the object.<p>
</p>
<h3><a name="17">isEmpty</a></h3>
<blockquote>- (BOOL)<b>isEmpty</b>
</blockquote>
Whether the number of elements is equal to zero.<p>
</p>
<h3><a name="18">eachElement</a></h3>
<blockquote>-<b>eachElement</b>
</blockquote>
Returns a sequence of sorted elements.  The first element in the sequence is the smallest with respect to the ordering.<p>
</p>
<blockquote><pre>
aSeq = [aSort eachElement];
while ((anElement = [aSeq next])) {
    /* do something */
}
aSeq = [aSeq free];
</pre></blockquote>
<h3><a name="19">hash</a></h3>
<blockquote>- (unsigned)<b>hash</b>
</blockquote>
Returns a hash value based on the receiver's address and the results of sending the <b>hash</b> message to the contents.<p>
</p>
<h3><a name="20">isEqual:</a></h3>
<blockquote>- (BOOL)<b>isEqual</b>:<i>aSort</i>
</blockquote>
Returns YES if <i>aSort</i> is an <b>SortCltn</b> instance, and if each member of its contents responds affirmatively to the message <b>isEqual:</b> when compared to the corresponding member of the receiver's contents.<p>
</p>
<h3><a name="21">add:</a></h3>
<blockquote>-<b>add</b>:<i>anObject</i>
</blockquote>
Adds <i>anObject</i> to the receiver, keeping the contents of the object sorted.  Duplicate entries are allowed.  Returns the receiver.<p>
</p>
<h3><a name="22">addNTest:</a></h3>
<blockquote>-<b>addNTest</b>:<i>anObject</i>
</blockquote>
Adds <i>anObject</i> if it was not previously in the set.  Returns <i>anObject</i> if the addition takes place, otherwise returns <b>nil</b>.<p>
</p>
<h3><a name="23">filter:</a></h3>
<blockquote>-<b>filter</b>:<i>anObject</i>
</blockquote>
If <i>anObject</i> compares equally to some object in the contents of the receiver, then <i>anObject</i> is freed, and the matching object is returned.  Otherwise, <i>anObject</i> is added and returned.<p>
</p>
<h3><a name="24">replace:</a></h3>
<blockquote>-<b>replace</b>:<i>anObject</i>
</blockquote>
If a matching object is found, then <i>anObject</i> replaces that object, and the matching object is returned.  If there is no matching object, <i>anObject</i> is added to the receiver, and <b>nil</b> is returned.<p>
</p>
<h3><a name="25">remove:</a></h3>
<blockquote>-<b>remove</b>:<i>oldObject</i>
</blockquote>
Removes <i>oldObject</i> or the element that matches (when the compare method returns zero).  Returns the removed entry, or <b>nil</b> if there is no matching entry.<p>
<b>Note:</b> Not implemented</p>
<p>
</p>
<h3><a name="34">includesAllOf:</a></h3>
<blockquote>- (BOOL)<b>includesAllOf</b>:<i>aCltn</i>
</blockquote>
Answer whether all the elements of <i>aCltn</i> are in the receiver, by sending <b>includes:</b> for each individual element.<p>
</p>
<h3><a name="35">includesAnyOf:</a></h3>
<blockquote>- (BOOL)<b>includesAnyOf</b>:<i>aCltn</i>
</blockquote>
Answer whether any element of <i>aCltn</i> is in the receiver, by sending <b>includes:</b> for each individual element.<p>
</p>
<h3><a name="36">addAll:</a></h3>
<blockquote>-<b>addAll</b>:<i>aCltn</i>
</blockquote>
Adds each member of <i>aCltn</i> to the receiver.  If <i>aCltn</i> is <b>nil</b>, no action is taken.  The argument <i>aCltn</i> need not be a collection, so long as it responds to <b>eachElement</b> in the same way as collections do.  Returns the receiver.<p>
<b>Note:</b> If <i>aCltn</i> is the same object as the receiver, a <b>addYourself</b> message is sent to the object.</p>
<p>
</p>
<h3><a name="37">addContentsOf:</a></h3>
<blockquote>-<b>addContentsOf</b>:<i>aCltn</i>
</blockquote>
This method is equivalent to <b>addAll:</b> and is provided for Stepstone ICpak101 compatibility.<p>
</p>
<h3><a name="38">addContentsTo:</a></h3>
<blockquote>-<b>addContentsTo</b>:<i>aCltn</i>
</blockquote>
This method is equivalent to <b>addAll:</b>, but with argument and receiver interchanged, and is provided for Stepstone ICpak101 compatibility.<p>
</p>
<h3><a name="39">removeAll:</a></h3>
<blockquote>-<b>removeAll</b>:<i>aCltn</i>
</blockquote>
Removes all of the members of <i>aCltn</i> from the receiver. The argument <i>aCltn</i> need not be a collection, as long as it responds to <b>eachElement</b> as collections do.  Returns the receiver. <p>
<b>Note:</b> If <i>aCltn</i> is the same object as the receiver, it empties itself using <b>emptyYourself</b> and returns the receiver.</p>
<p>
</p>
<h3><a name="40">removeContentsFrom:</a></h3>
<blockquote>-<b>removeContentsFrom</b>:<i>aCltn</i>
</blockquote>
This method is equivalent to <b>removeAll:</b>, and is provided for compatibility with Stepstone ICpak101.<p>
</p>
<h3><a name="41">removeContentsOf:</a></h3>
<blockquote>-<b>removeContentsOf</b>:<i>aCltn</i>
</blockquote>
This method is equivalent to <b>removeAll:</b>, and is provided for compatibility with Stepstone ICpak101.<p>
</p>
<h3><a name="42">intersection:</a></h3>
<blockquote>-<b>intersection</b>:<i>bag</i>
</blockquote>
Returns a new Collection which is the intersection of the receiver and <i>bag</i>.  The new Collection contains only those elements that were in both the receiver and <i>bag</i>.  The argument <i>bag</i> need not be an actual <b>Set</b> or <b>Bag</b> instance, as long as it implements <b>find:</b> as Sets do.<p>
</p>
<h3><a name="43">union:</a></h3>
<blockquote>-<b>union</b>:<i>bag</i>
</blockquote>
Returns a new Collection which is the union of the receiver and <i>bag</i>.  The new Collection returned has all the elements from both the receiver and <i>bag</i>.  The argument <i>bag</i> need not be an actual <b>Set</b> or <b>Bag</b> instance, as long as it implements <b>eachElement:</b> as Sets and Bags do.<p>
</p>
<h3><a name="44">difference:</a></h3>
<blockquote>-<b>difference</b>:<i>bag</i>
</blockquote>
Returns a new Collection which is the difference of the receiver and <i>bag</i>.  The new Collection returned has only those elements in the receiver that are not in <i>bag</i>.<p>
</p>
<h3><a name="45">asSet</a></h3>
<blockquote>-<b>asSet</b>
</blockquote>
Creates a <b>Set</b> instance and adds the contents of the object to the set.<p>
</p>
<h3><a name="46">asOrdCltn</a></h3>
<blockquote>-<b>asOrdCltn</b>
</blockquote>
Creates a <b>OrdCltn</b> instance and adds the contents of the object to the set.<p>
</p>
<h3><a name="47">detect:</a></h3>
<blockquote>-<b>detect</b>:<i>aBlock</i>
</blockquote>
This message returns the first element in the receiver for which <i>aBlock</i> evaluates to something that is non-nil .  For example, the following :<p>
</p>
<blockquote><pre>
[ aCltn detect: { :each | [each isEqual:anObject] } ];
</pre></blockquote>
Returns <b>nil</b> if there's no element for which <i>aBlock</i> evaluates to something that non-nil.<p>
</p>
<h3><a name="48">detect:ifNone:</a></h3>
<blockquote>-<b>detect</b>:<i>aBlock</i><b>ifNone</b>:<i>noneBlock</i>
</blockquote>
This message returns the first element in the receiver for which <i>aBlock</i> evaluates to something that is non-nil.<p>
Evaluates <i>noneBlock</i> if there's no element for which <i>aBlock</i> evaluates to something that is non-nil, and returns the return value of that block.  For example,</p>
<p>
</p>
<blockquote><pre>
[ aCltn detect: { :e | [e isEqual:anObject]} ifNone: {anObject} ];
</pre></blockquote>
<h3><a name="49">select:</a></h3>
<blockquote>-<b>select</b>:<i>testBlock</i>
</blockquote>
This message will return a subset of the receiver containing all elements for which <i>testBlock</i> evaluates to an Object that is non-nil.  For example,<p>
</p>
<blockquote><pre>
[ aCltn select: { :each | [each isEqual:anObject] } ];
</pre></blockquote>
Returns a new empty instance of the same class as the receiver, if there's no element for which <i>testBlock</i> evaluates to something that is non-nil. <p>
</p>
<h3><a name="50">reject:</a></h3>
<blockquote>-<b>reject</b>:<i>testBlock</i>
</blockquote>
Complement of <b>select:</b><p>
This message will return a subset of the receiver containing all elements for which <i>testBlock</i> evaluates to nil.  For example,</p>
<p>
</p>
<blockquote><pre>
[ aCltn reject: { :each | [each isEqual:anObject] } ];
</pre></blockquote>
Returns a new empty instance of the same class as the receiver, if there's no element for which <i>testBlock</i> evaluates to nil.<p>
</p>
<h3><a name="51">collect:</a></h3>
<blockquote>-<b>collect</b>:<i>transformBlock</i>
</blockquote>
This message creates and returns a new collection of the same size and type as the receiver. The elements are the result of performing <i>transformBlock</i> on each element in the receiver (elements for which the Block would return <b>nil</b> are filtered out).<p>
</p>
<h3><a name="52">count:</a></h3>
<blockquote>- (unsigned)<b>count</b>:<i>aBlock</i>
</blockquote>
Evaluate <i>aBlock</i> with each of the receiver's elements as the argument.  Return the number that answered a non-<b>nil</b> value.<p>
</p>
<h3><a name="53">elementsPerform:</a></h3>
<blockquote>-<b>elementsPerform</b>:(SEL)<i>aSelector</i>
</blockquote>
Send <i>aSelector</i> to all objects in the collection, starting from the object at offset <i>0</i>.  For Stepstone compatibility.  Producer uses this.<p>
</p>
<h3><a name="54">elementsPerform:with:</a></h3>
<blockquote>-<b>elementsPerform</b>:(SEL)<i>aSelector</i><b>with</b>:<i>anObject</i>
</blockquote>
Send <i>aSelector</i> to all objects in the collection, starting from the object at offset <i>0</i>.  For Stepstone compatibility.  Producer uses this.<p>
</p>
<h3><a name="55">elementsPerform:with:with:</a></h3>
<blockquote>-<b>elementsPerform</b>:(SEL)<i>aSelector</i><b>with</b>:<i>anObject</i><b>with</b>:<i>otherObject</i>
</blockquote>
Send <i>aSelector</i> to all objects in the collection, starting from the object at offset <i>0</i>.  For Stepstone compatibility.  Producer uses this.<p>
</p>
<h3><a name="56">elementsPerform:with:with:with:</a></h3>
<blockquote>-<b>elementsPerform</b>:(SEL)<i>aSelector</i><b>with</b>:<i>anObject</i><b>with</b>:<i>otherObject</i><b>with</b>:<i>thirdObj</i>
</blockquote>
Send <i>aSelector</i> to all objects in the collection, starting from the object at offset <i>0</i>.  For Stepstone compatibility.  ICpak201 uses this.<p>
</p>
<h3><a name="57">do:</a></h3>
<blockquote>-<b>do</b>:<i>aBlock</i>
</blockquote>
Evaluates <i>aBlock</i> for each element in the collection and returns <b>self</b>.  <i>aBlock</i> must be a block taking one object (element) as argument; the return value of the block is ignored by this method.<p>
Often, the Block would, as a side-effect, modify a variable, as in:</p>
<p>
</p>
<blockquote><pre>
int count = 0;
[contents do: { :what | if (what == anObject) count++; }];
</pre></blockquote>
<h3><a name="58">do:until:</a></h3>
<blockquote>-<b>do</b>:<i>aBlock</i><b>until</b>:(BOOL*)<i>flag</i>
</blockquote>
Evaluates <i>aBlock</i> for each element in the collection, or until the variable pointed to by <i>flag</i> becomes true, and returns <b>self</b>.  <i>aBlock</i> must be a block taking one object (element) as argument; the return value of the block is ignored by this method.<p>
Typically the Block will modify the variable <i>flag</i> when some condition holds:</p>
<p>
</p>
<blockquote><pre>
BOOL found = NO;
[contents do:{ :what | if (what == findObject) found=YES;} until:&amp;found];
if (found) { ... }
</pre></blockquote>
<h3><a name="26">find:</a></h3>
<blockquote>-<b>find</b>:<i>anObject</i>
</blockquote>
Returns any element in the receiver which <b>isEqual:</b> to <i>anObject</i>.  Otherwise, returns <b>nil</b>.<p>
</p>
<h3><a name="27">contains:</a></h3>
<blockquote>- (BOOL)<b>contains</b>:<i>anObject</i>
</blockquote>
Returns YES if the receiver contains <i>anObject</i>.  Otherwise, returns NO.  Implementation is in terms of the receiver's <b>find:</b> method.<p>
</p>
<h3><a name="28">printOn:</a></h3>
<blockquote>-<b>printOn</b>:(IOD)<i>aFile</i>
</blockquote>
Prints a comma separated list of the objects in the set by sending each individual object a <b>printOn:</b> message.  Returns the receiver.<p>
</p>
<h3><a name="29">fileOutOn:</a></h3>
<blockquote>-<b>fileOutOn</b>:<i>aFiler</i>
</blockquote>
Writes the tree and all its elements to <i>aFiler</i>.  Returns the receiver.<p>
</p>
<h3><a name="30">fileInFrom:</a></h3>
<blockquote>-<b>fileInFrom</b>:<i>aFiler</i>
</blockquote>
Reads the tree and all its elements from <i>aFiler</i>.  Returns the receiver.<p></p>
</body>
</html>
