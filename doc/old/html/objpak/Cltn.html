<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ascii">
<title>cltn Specification Sheet</title>
</head>
<body>
<h1>cltn Specification Sheet</h1>

<hr>
Portable Object Compiler (c) 1997,98,2003.  All Rights Reserved.<p>
</p>
<h1>Cltn</h1>
<b>Inherits from:</b> Object<p>
</p>
<h2>Class Description</h2>
This is an abstract superclass for collection classes.<p>
It is useful for implementing functionality, that is inherited by such classes as:</p>
<p>
</p>
<ul>
<li>OrdCltn (Collection)</li>
<li>Set</li>
<li>Stack</li>
<li>SortCltn (Tree)</li>
</ul>
In addition, this class is necessary for compatibility with Stepstone's ICpak101.<p>
</p>
<h2>Method types</h2>
<h3><b>Testing Contents</b></h3>
<ul>
<li><a href="#10">includesAllOf:</a></li>
<li><a href="#11">includesAnyOf:</a></li>
</ul>
<h3><b>Adding and Removing Contents</b></h3>
<ul>
<li><a href="#12">addAll:</a></li>
<li><a href="#13">addContentsOf:</a></li>
<li><a href="#14">addContentsTo:</a></li>
<li><a href="#15">removeAll:</a></li>
<li><a href="#16">removeContentsFrom:</a></li>
<li><a href="#17">removeContentsOf:</a></li>
</ul>
<h3><b>Combining</b></h3>
<ul>
<li><a href="#18">intersection:</a></li>
<li><a href="#19">union:</a></li>
<li><a href="#20">difference:</a></li>
</ul>
<h3><b>Converting</b></h3>
<ul>
<li><a href="#21">asSet</a></li>
<li><a href="#22">asOrdCltn</a></li>
</ul>
<h3><b>Using Blocks</b></h3>
<ul>
<li><a href="#23">detect:</a></li>
<li><a href="#24">detect:ifNone:</a></li>
<li><a href="#25">select:</a></li>
<li><a href="#26">reject:</a></li>
<li><a href="#27">collect:</a></li>
<li><a href="#28">count:</a></li>
</ul>
<h3><b>Making elements perform</b></h3>
<ul>
<li><a href="#29">elementsPerform:</a></li>
<li><a href="#30">elementsPerform:with:</a></li>
<li><a href="#31">elementsPerform:with:with:</a></li>
<li><a href="#32">elementsPerform:with:with:with:</a></li>
</ul>
<h3><b>Do Blocks</b></h3>
<ul>
<li><a href="#33">do:</a></li>
<li><a href="#34">do:until:</a></li>
</ul>
<h2>Methods</h2>
<h3><a name="7">with:</a></h3>
<blockquote>+<b>with</b>:(int)<i>nArgs,...</i>
</blockquote>
Returns a new object with <i>nArgs</i> elements.  For example,<p>
</p>
<blockquote><pre>
id aCltn = [OrdCltn with:2,anObject,otherObject];
</pre></blockquote>
creates a collection and adds <i>anObject</i> and <i>otherObject</i> to it.  In a similar way, <b>Set</b> or <b>SortCltn</b> instances can be created like this.<p>
</p>
<h3><a name="8">with:with:</a></h3>
<blockquote>+<b>with</b>:<i>firstObject</i><b>with</b>:<i>nextObject</i>
</blockquote>
This method is equivalent to <b>with:</b> 2,<i>firstObject</i>,<i>nextObject</i>. <p>
</p>
<h3><a name="9">add:</a></h3>
<blockquote>+<b>add</b>:<i>firstObject</i>
</blockquote>
This method is equivalent to <b>with:</b> 1,<i>firstObject</i>. <p>
This (factory) method has the same name as the instance method <b>add:</b> and can be used as follows, in circumstances when the user does not want to allocate a collection unless it is actually used :</p>
<p>
</p>
<blockquote><pre>
aCltn = [ (aCltn)?aCltn:OrdCltn add:myObject ];
</pre></blockquote>
This shows that creation of the collection is delayed until it is actually needed.  If the collection already exists, objects are simply added, using the instance method <b>add:</b>.<p>
</p>
<h3><a name="10">includesAllOf:</a></h3>
<blockquote>- (BOOL)<b>includesAllOf</b>:<i>aCltn</i>
</blockquote>
Answer whether all the elements of <i>aCltn</i> are in the receiver, by sending <b>includes:</b> for each individual element.<p>
</p>
<h3><a name="11">includesAnyOf:</a></h3>
<blockquote>- (BOOL)<b>includesAnyOf</b>:<i>aCltn</i>
</blockquote>
Answer whether any element of <i>aCltn</i> is in the receiver, by sending <b>includes:</b> for each individual element.<p>
</p>
<h3><a name="12">addAll:</a></h3>
<blockquote>-<b>addAll</b>:<i>aCltn</i>
</blockquote>
Adds each member of <i>aCltn</i> to the receiver.  If <i>aCltn</i> is <b>nil</b>, no action is taken.  The argument <i>aCltn</i> need not be a collection, so long as it responds to <b>eachElement</b> in the same way as collections do.  Returns the receiver.<p>
<b>Note:</b> If <i>aCltn</i> is the same object as the receiver, a <b>addYourself</b> message is sent to the object.</p>
<p>
</p>
<h3><a name="13">addContentsOf:</a></h3>
<blockquote>-<b>addContentsOf</b>:<i>aCltn</i>
</blockquote>
This method is equivalent to <b>addAll:</b> and is provided for Stepstone ICpak101 compatibility.<p>
</p>
<h3><a name="14">addContentsTo:</a></h3>
<blockquote>-<b>addContentsTo</b>:<i>aCltn</i>
</blockquote>
This method is equivalent to <b>addAll:</b>, but with argument and receiver interchanged, and is provided for Stepstone ICpak101 compatibility.<p>
</p>
<h3><a name="15">removeAll:</a></h3>
<blockquote>-<b>removeAll</b>:<i>aCltn</i>
</blockquote>
Removes all of the members of <i>aCltn</i> from the receiver. The argument <i>aCltn</i> need not be a collection, as long as it responds to <b>eachElement</b> as collections do.  Returns the receiver. <p>
<b>Note:</b> If <i>aCltn</i> is the same object as the receiver, it empties itself using <b>emptyYourself</b> and returns the receiver.</p>
<p>
</p>
<h3><a name="16">removeContentsFrom:</a></h3>
<blockquote>-<b>removeContentsFrom</b>:<i>aCltn</i>
</blockquote>
This method is equivalent to <b>removeAll:</b>, and is provided for compatibility with Stepstone ICpak101.<p>
</p>
<h3><a name="17">removeContentsOf:</a></h3>
<blockquote>-<b>removeContentsOf</b>:<i>aCltn</i>
</blockquote>
This method is equivalent to <b>removeAll:</b>, and is provided for compatibility with Stepstone ICpak101.<p>
</p>
<h3><a name="18">intersection:</a></h3>
<blockquote>-<b>intersection</b>:<i>bag</i>
</blockquote>
Returns a new Collection which is the intersection of the receiver and <i>bag</i>.  The new Collection contains only those elements that were in both the receiver and <i>bag</i>.  The argument <i>bag</i> need not be an actual <b>Set</b> or <b>Bag</b> instance, as long as it implements <b>find:</b> as Sets do.<p>
</p>
<h3><a name="19">union:</a></h3>
<blockquote>-<b>union</b>:<i>bag</i>
</blockquote>
Returns a new Collection which is the union of the receiver and <i>bag</i>.  The new Collection returned has all the elements from both the receiver and <i>bag</i>.  The argument <i>bag</i> need not be an actual <b>Set</b> or <b>Bag</b> instance, as long as it implements <b>eachElement:</b> as Sets and Bags do.<p>
</p>
<h3><a name="20">difference:</a></h3>
<blockquote>-<b>difference</b>:<i>bag</i>
</blockquote>
Returns a new Collection which is the difference of the receiver and <i>bag</i>.  The new Collection returned has only those elements in the receiver that are not in <i>bag</i>.<p>
</p>
<h3><a name="21">asSet</a></h3>
<blockquote>-<b>asSet</b>
</blockquote>
Creates a <b>Set</b> instance and adds the contents of the object to the set.<p>
</p>
<h3><a name="22">asOrdCltn</a></h3>
<blockquote>-<b>asOrdCltn</b>
</blockquote>
Creates a <b>OrdCltn</b> instance and adds the contents of the object to the set.<p>
</p>
<h3><a name="23">detect:</a></h3>
<blockquote>-<b>detect</b>:<i>aBlock</i>
</blockquote>
This message returns the first element in the receiver for which <i>aBlock</i> evaluates to something that is non-nil .  For example, the following :<p>
</p>
<blockquote><pre>
[ aCltn detect: { :each | [each isEqual:anObject] } ];
</pre></blockquote>
Returns <b>nil</b> if there's no element for which <i>aBlock</i> evaluates to something that non-nil.<p>
</p>
<h3><a name="24">detect:ifNone:</a></h3>
<blockquote>-<b>detect</b>:<i>aBlock</i><b>ifNone</b>:<i>noneBlock</i>
</blockquote>
This message returns the first element in the receiver for which <i>aBlock</i> evaluates to something that is non-nil.<p>
Evaluates <i>noneBlock</i> if there's no element for which <i>aBlock</i> evaluates to something that is non-nil, and returns the return value of that block.  For example,</p>
<p>
</p>
<blockquote><pre>
[ aCltn detect: { :e | [e isEqual:anObject]} ifNone: {anObject} ];
</pre></blockquote>
<h3><a name="25">select:</a></h3>
<blockquote>-<b>select</b>:<i>testBlock</i>
</blockquote>
This message will return a subset of the receiver containing all elements for which <i>testBlock</i> evaluates to an Object that is non-nil.  For example,<p>
</p>
<blockquote><pre>
[ aCltn select: { :each | [each isEqual:anObject] } ];
</pre></blockquote>
Returns a new empty instance of the same class as the receiver, if there's no element for which <i>testBlock</i> evaluates to something that is non-nil. <p>
</p>
<h3><a name="26">reject:</a></h3>
<blockquote>-<b>reject</b>:<i>testBlock</i>
</blockquote>
Complement of <b>select:</b><p>
This message will return a subset of the receiver containing all elements for which <i>testBlock</i> evaluates to nil.  For example,</p>
<p>
</p>
<blockquote><pre>
[ aCltn reject: { :each | [each isEqual:anObject] } ];
</pre></blockquote>
Returns a new empty instance of the same class as the receiver, if there's no element for which <i>testBlock</i> evaluates to nil.<p>
</p>
<h3><a name="27">collect:</a></h3>
<blockquote>-<b>collect</b>:<i>transformBlock</i>
</blockquote>
This message creates and returns a new collection of the same size and type as the receiver. The elements are the result of performing <i>transformBlock</i> on each element in the receiver (elements for which the Block would return <b>nil</b> are filtered out).<p>
</p>
<h3><a name="28">count:</a></h3>
<blockquote>- (unsigned)<b>count</b>:<i>aBlock</i>
</blockquote>
Evaluate <i>aBlock</i> with each of the receiver's elements as the argument.  Return the number that answered a non-<b>nil</b> value.<p>
</p>
<h3><a name="29">elementsPerform:</a></h3>
<blockquote>-<b>elementsPerform</b>:(SEL)<i>aSelector</i>
</blockquote>
Send <i>aSelector</i> to all objects in the collection, starting from the object at offset <i>0</i>.  For Stepstone compatibility.  Producer uses this.<p>
</p>
<h3><a name="30">elementsPerform:with:</a></h3>
<blockquote>-<b>elementsPerform</b>:(SEL)<i>aSelector</i><b>with</b>:<i>anObject</i>
</blockquote>
Send <i>aSelector</i> to all objects in the collection, starting from the object at offset <i>0</i>.  For Stepstone compatibility.  Producer uses this.<p>
</p>
<h3><a name="31">elementsPerform:with:with:</a></h3>
<blockquote>-<b>elementsPerform</b>:(SEL)<i>aSelector</i><b>with</b>:<i>anObject</i><b>with</b>:<i>otherObject</i>
</blockquote>
Send <i>aSelector</i> to all objects in the collection, starting from the object at offset <i>0</i>.  For Stepstone compatibility.  Producer uses this.<p>
</p>
<h3><a name="32">elementsPerform:with:with:with:</a></h3>
<blockquote>-<b>elementsPerform</b>:(SEL)<i>aSelector</i><b>with</b>:<i>anObject</i><b>with</b>:<i>otherObject</i><b>with</b>:<i>thirdObj</i>
</blockquote>
Send <i>aSelector</i> to all objects in the collection, starting from the object at offset <i>0</i>.  For Stepstone compatibility.  ICpak201 uses this.<p>
</p>
<h3><a name="33">do:</a></h3>
<blockquote>-<b>do</b>:<i>aBlock</i>
</blockquote>
Evaluates <i>aBlock</i> for each element in the collection and returns <b>self</b>.  <i>aBlock</i> must be a block taking one object (element) as argument; the return value of the block is ignored by this method.<p>
Often, the Block would, as a side-effect, modify a variable, as in:</p>
<p>
</p>
<blockquote><pre>
int count = 0;
[contents do: { :what | if (what == anObject) count++; }];
</pre></blockquote>
<h3><a name="34">do:until:</a></h3>
<blockquote>-<b>do</b>:<i>aBlock</i><b>until</b>:(BOOL*)<i>flag</i>
</blockquote>
Evaluates <i>aBlock</i> for each element in the collection, or until the variable pointed to by <i>flag</i> becomes true, and returns <b>self</b>.  <i>aBlock</i> must be a block taking one object (element) as argument; the return value of the block is ignored by this method.<p>
Typically the Block will modify the variable <i>flag</i> when some condition holds:</p>
<p>
</p>
<blockquote><pre>
BOOL found = NO;
[contents do:{ :what | if (what == findObject) found=YES;} until:&amp;found];
if (found) { ... }
</pre></blockquote>
</body>
</html>
